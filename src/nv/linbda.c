#include <stdio.h>

#define	_LINBDA_DATE	"14/09/2001 10:30"

static  char	VersionStatus[16]= { 
	'V','E','R','S','I','O','N','_','S','T','A','T','U','S',':','2' 
	};

static	char 	LaPaterne[32] = { 
	'*','P','R','L','@','I','N','F','O','*','#',6,'1','1','a','0','0','3',0
	};

static	char *	targetname=(char *) 0;
static	char *  argvzero="LINBDA";
static	char *	LaPointeur=(char*)0;
static	char 	LaVersion[16];

static	int	explicite_numbering=0;
static	int	comment_tabulator=0;
static	int	special=0;
static	int	verbose=0;
static	int	debug=0;
static	char *	trace_name=(char*)0;
static	int	echo=0;
static	int	function_counter=0;
static	int	state_machine=0;

char *	getpatternversion()
{
	if (!( LaPointeur )) {
		LaVersion[0] = LaPaterne[12];
		LaVersion[1] = '.';
		LaVersion[2] = LaPaterne[13];
		LaVersion[3] = LaPaterne[14];
		if ( VersionStatus[15] != '0' ) {
			LaVersion[4] = '.';
			LaVersion[5] = LaPaterne[15];
			LaVersion[6] = '.';
			LaVersion[7] = LaPaterne[16];
			LaVersion[8] = LaPaterne[17];
			LaVersion[9] = 0;
			}
		else if ( LaPaterne[15] != '0' ) {
			LaVersion[4] = '.';
			LaVersion[5] = LaPaterne[15];
			LaVersion[6] = 0;
			}
		else	LaVersion[4] = 0;

		LaPointeur = LaVersion;
		}
	return( LaPointeur );

}

int	banner(char * cptr)
{
	printf("\n   ABAL Dynamic Library Interface Generator : Version %s ",getpatternversion());
	if ( VersionStatus[15] == '2' )
		printf("\n   Provisoire du %s ",_LINBDA_DATE );
	printf("\n   Copyright (c) 1987-2006 Amenesik / Sologic \n");
	printf("\n   Syntax : \n");
	printf("\n          %s [ -vexdfilename ]  filename\n",cptr);
	printf("\n          -v          : activate messages during conversion");
	printf("\n          -e          : echo source file to std output");
	printf("\n          -x          : variable parameter count functions");
	printf("\n          -dname      : generate trace information");
	printf("\n          -rname      : indicate result filename\n\n");

	return(0);
}


int	option( char * sptr )
{
	while ( *sptr ) {
		switch ( *(sptr++) ) {
			case	'r'	:
			case	'R'	:
				targetname = sptr;
				return(1);

			case	'D'	:
			case	'd'	:
				debug=1;
				if ( *sptr )
					trace_name = sptr;
				return(1);

			case	'X'	:
			case	'x'	:
				special = 1;
				continue;
			case	'V'	:
			case	'v'	:
				verbose = 1;
				continue;
			case	'e'	:
			case	'E'	:
				echo = 1;
				continue;
			default		:
				printf("\n*** error:incorrect option %s ***\n",sptr);
				return(0);
			}
		}
	return(1);
}

char	namebuffer[512];
char	workbuffer[1024];
char	linebuffer[1024];
int	LinDex=0;

void	generate_comment( FILE * target, char * message ) 
{ 
	int	i;
	for ( i=0; i < comment_tabulator; i++ )
		fprintf(target,"\t");

	fprintf(target,"/* %s */\n",message);
	return;
}

void	generate_header( FILE * target, char * namestub )
{
	state_machine=0;
	sprintf(workbuffer,"File generated by %s : %s.def -> %s.c",argvzero,namestub,namestub);
	generate_comment( target, workbuffer );
	fprintf(target,"#ifndef __linbda_%s_c__\n",namestub);
	fprintf(target,"#define __linbda_%s_c__\n",namestub);

	if ( debug ) 
		fprintf(target,"#include <stdio.h>\n");

	fprintf(target,"#include %cldfbda.h%c\n",0x022,0x022);

	fprintf(target,"\nstatic BDA * DynamicLibrary;\n");
	fprintf(target,"\tLPBDA_INIT\trt_init;\n");
	fprintf(target,"\tBDA_INIT\tv_rt_init;\n");

	fprintf(target,"\tBDA_ARG rt_arg;\n\n");

	fprintf(target,"\tVOID rt_error(WORD evalue) { return; }\n");


	fprintf(target,"\nstatic int function_counter=%u;\n",(function_counter=0));

	generate_comment(target,"ABAL Word Convertor");
	fprintf(target,"static WORD LdfAbalWord(BYTE FAR PTR wptr)\n");
	fprintf(target,"{\n");
	fprintf(target,"\treturn(((*wptr<< 8) | *(wptr+1)));\n");
	fprintf(target,"}\n\n");
	
	if ( debug ) {


		fprintf(target,"\nstatic int trace_name=(char*)0;\n");
		fprintf(target,"\nstatic int trace_handle=(FILE*)0;\n");

		generate_comment(target,"Trace Activation");
		fprintf(target,"static void start_trace()\n");
		fprintf(target,"{\n");
		if ( trace_name != (char *) 0 )
			fprintf(target,"\ttrace_name = %c%s%c;\n",0x0022,trace_name,0x0022);
		else	fprintf(target,"\ttrace_name = getenv(%c%s%c);\n",0x0022,"LINBDA_OUTPUT",0x0022);
		fprintf(target,"\ttrace_handle=fopen(trace_name,%cw%c);\n",0x0022,0x0022);
		fprintf(target,"\treturn;\n");
		fprintf(target,"}\n\n");

		generate_comment(target,"Trace Write");
		fprintf(target,"static void write_trace(char * mptr)\n");
		fprintf(target,"{\n\tif ( trace_handle != (FILE*)0) {\n");
		fprintf(target,"\t\tfprintf(trace_handle,mptr);\n");
		fprintf(target,"\t\tfprintf(trace_handle,%c%cn%c);\n",0x0022,0x005C,0x0022);
		fprintf(target,"\t\t}\n\treturn;\n");
		fprintf(target,"}\n\n");

		generate_comment(target,"Trace Call");
		fprintf(target,"static void trace_call(\n\tWORD fid,\n\tWORD argc,\n\tBYTE FAR tptr[],\n\tVOID FAR PTR FAR pptr[],\n\tWORD FAR wptr[])\n");
		fprintf(target,"{\n\tchar * bptr;\n\tint\ti=0;\n\tint\tj=0;\n\tif ( trace_handle != (FILE*)0) {\n");
		fprintf(target,"\t\tfprintf(trace_handle,");
		fprintf(target,"%c(call %cu)%c,fid);\n",
				0x0022, 0x0025, 0x0022);
		fprintf(target,"\t\tfor (i=0; i < argc; i++) {\n");
		fprintf(target,"\t\t\tswitch(tptr[i]) {\n");
		fprintf(target,"\t\t\t\tcase 0x0080 : \n");
		fprintf(target,"\t\t\t\tcase 0  : \n");
		fprintf(target,"\t\t\t\t\tfprintf(trace_handle,%c%ct(b=%cx)%cn%c,*((bptr=pptr[i])));\n",
				0x0022,0x005C,0x0025,0x005C,0x0022);
		fprintf(target,"\t\t\t\t\tbreak;\n");
		fprintf(target,"\t\t\t\tcase 0x0081 : \n");
		fprintf(target,"\t\t\t\tcase 1  : \n");
		fprintf(target,"\t\t\t\t\tfprintf(trace_handle,%c%ct(w=%cx)%cn%c,LdfAbalWord(pptr[i]));\n",
				0x0022,0x005C,0x0025,0x005C,0x0022);
		fprintf(target,"\t\t\t\t\tbreak;\n");
		fprintf(target,"\t\t\t\tcase 2  : \n");
		fprintf(target,"\t\t\t\tcase 3  : \n");
		fprintf(target,"\t\t\t\tcase 0x0082 : \n");
		fprintf(target,"\t\t\t\tcase 0x0083 : \n");

		fprintf(target,"\t\t\t\t\tfprintf(trace_handle,%c%ct(*=%c);\n",
				0x0022,0x005C,0x0022);
		fprintf(target,"\t\t\t\t\tfor (bptr=pptr[i],j=0;j<wptr[i];j++) {\n");
		fprintf(target,"\t\t\t\t\t\tfprintf(trace_handle,%c%cx %c,(*(bptr+j)&0x00FF));\n",
				0x0022,0x0025,0x0022);

		fprintf(target,"\t\t\t\t\t\t}\n");
		fprintf(target,"\t\t\t\t\tfprintf(trace_handle,%c)%cn%c);\n",0x0022,0x005C,0x0022);

		fprintf(target,"\t\t\t\t};\n");
		fprintf(target,"\t\t\t}\n");
		fprintf(target,"\t\tfprintf(trace_handle,%c%cn%c);\n",0x0022,0x005C,0x0022);
		fprintf(target,"\t\t}\n\treturn;\n");
		fprintf(target,"}\n\n");

		generate_comment(target,"Trace Closure");
		fprintf(target,"static void close_trace()\n");
		fprintf(target,"{\n\tif ( trace_handle != (FILE*)0) {\n");
		fprintf(target,"\t\tfclose(trace_handle);\n");
		fprintf(target,"\t\ttrace_handle=(FILE*)0;\n");
		fprintf(target,"\t\t}\n\treturn;\n");
		fprintf(target,"}\n\n");

		}

	generate_comment(target,"Library Destructor");
	fprintf(target,"WORD LdfBdaTerminate()\n");
	fprintf(target,"{\n");

	if ( debug ) {
		fprintf(target,"\twrite_trace(%cLdfBdaTerminate()%c);\n",0x0022,0x0022);
		fprintf(target,"\tclose_trace();\n");
		}

	fprintf(target,"\tif (DynamicLibrary->fin != (VOID (FAR PTR)()) 0)\n");
	fprintf(target,"\t\t (*DynamicLibrary->fin)();\n");
	fprintf(target,"\treturn(0);\n");
	fprintf(target,"}\n\n");

	generate_comment(target,"Library Call Through");
	fprintf(target,"WORD LdfBdaExecute(\n\tWORD fid,\n\tWORD argc,\n\tBYTE FAR tptr[],\n\tVOID FAR PTR FAR pptr[],\n\tWORD FAR wptr[])\n");
	fprintf(target,"{\n");

	fprintf(target,"\trt_arg.c=argc; rt_arg.v=pptr;\n");
	fprintf(target,"\trt_arg.l=wptr; rt_arg.t=tptr;\n");

	if ( debug ) 
		fprintf(target,"\ttrace_call(fid,argc,tptr,pptr,wptr);\n");

	comment_tabulator=1;

}

void	generate_footer( FILE * target, char * namestub )
{
	fprintf(target,"\treturn(0);\n");
	fprintf(target,"}\n\n");
	comment_tabulator = 0;

	generate_comment(target,"Library Constructor");
	fprintf(target,"\nWORD LdfBdaInitialise(\n\tBDA_INIT FAR PTR descriptor,\n\tWORD dlength)\n");
	fprintf(target,"{\n");
	fprintf(target,"\tfunction_counter=%u;\n",function_counter);

	if ( debug ) {
		fprintf(target,"\tstart_trace();\n");
		fprintf(target,"\twrite_trace(%cLdfBdaInitialise()%c);\n",0x0022,0x0022);
		}

	fprintf(target,"\tif (!(DynamicLibrary = InitRelais()))\n");
	fprintf(target,"\t\treturn(139);\n");
	fprintf(target,"\telse\treturn(0);\n");

	fprintf(target,"}\n\n");

	fprintf(target,"#endif  /* __linbda_%s_c__ */\n",namestub);
	generate_comment( target, "End of File");
	return;
}

int	get_line( FILE * handle )
{
	int	lindent=0;
	int	c;
	while (1) {

		switch ((c = fgetc(handle))) {
			case	0	:
			case	-1	:
			case	0x001A	:
				linebuffer[lindent] = 0;
				if ( lindent ) {
					if ( echo )
						printf("%s\n",linebuffer);
					}
				return( lindent );
			case	';'	:
				while((c = fgetc(handle)) != '\n') {
					switch(c) {
						case	0	:
						case	-1	:
						case	0x001A	:
							if ( lindent ) {
								linebuffer[lindent] = 0;
								if ( echo )
									printf("%s\n",linebuffer);
								return( lindent );
								}
							else	return(0);
						}
					}

			case	'\n'	:
				if ( lindent ) {
					linebuffer[lindent] = 0;
					if ( echo )
						printf("%s\n",linebuffer);
					return( lindent );
					}
			case	'\r'	:
				continue;

			case	'\t'	:
				c = ' ';
			default		:
				if ( lindent < 1023 ) {
					if (( c != ' ' )
					||  (lindent != 0))
						linebuffer[lindent++] = c;
					continue;
					}
				else	return(0);
			}
		}
}

int	detect( char * sptr )
{
	int	i=0;
	while ( *(sptr+i) ) {
		if ( *(sptr+i) != (linebuffer[i] & 0x005F))
			return(0);
		else	i++;
		}
	return(1);
}

int	next_parameter()
{
	int	apt=0;
	while ( linebuffer[LinDex] == ' ' )
		LinDex++;

	switch ( linebuffer[LinDex++] ) {
		case	')'	:
			return(-1);
		case	'$'	:	/* STRING */
			apt = 3;
			break;
		case	'#'	:	/* INT  8 */
			apt = 0;
			break;
		case	'*'	:	/* BCD ?? */
			apt = 2;
			break;
		case	0x0025	:	/* INT 16 */
			apt = 1;
			break;
		default		:
			return(-1);
		}

	while ( linebuffer[LinDex] == ' ' )
		LinDex++;

	if ( linebuffer[LinDex] == '?' ) {
		LinDex++;
		apt |= 0x0080;
		}

	while ( linebuffer[LinDex] == ' ' )
		LinDex++;

	if ( linebuffer[LinDex] == ',' ) {
		LinDex++;
		apt |= 16;
		}

	else if ( linebuffer[LinDex] != ')' ) {
		return( -1 );
		}

	return(apt);

}

int	get_explicite()
{
	int	result=0;
	LinDex = 0;
	while ( linebuffer[LinDex] == ' ' )
		LinDex++;
	while (1) {
		if ((linebuffer[LinDex] >= '0')
		&&  (linebuffer[LinDex] <= '9'))
			result = ((result * 10) + (linebuffer[LinDex++] - '0'));
		else	break;
		}
	if ( linebuffer[LinDex] = ':' )
		LinDex++;
	while ( linebuffer[LinDex] == ' ' )
		LinDex++;
	return(result);
}

int	first_parameter()
{
	int	apt=-1;

	if (!( explicite_numbering ))
		LinDex = 0;

	while ( linebuffer[LinDex] == ' ' )
		LinDex++;

	switch ( linebuffer[LinDex] ) {
		case	'$'	:
			apt=3;
			break;
		case	'*'	:
			apt = 2;
			break;
		default		:
			apt = -1;
		}

	for (LinDex=0; linebuffer[LinDex] != 0; LinDex++ ) {
		if ( linebuffer[LinDex] == '(' ) {
			LinDex++;
			if ( apt != -1 ) {
				while ( linebuffer[LinDex] == ' ' )
					LinDex++;
				if ( linebuffer[LinDex] != ')' )
					apt |= 16;
				return(apt);
				}
			else	return( next_parameter() );
			}
		}
	return(-1);
}


void	generate_int8( FILE * handle, int item )
{
	fprintf(handle,"\n\t\t\t\t*(((BYTE FAR PTR)pptr[%u]))",item);
	return;
}
void	generate_int16( FILE * handle, int item )
{
	fprintf(handle,"\n\t\t\t\tLdfAbalWord(pptr[%u])",item);
	return;
}

void	generate_ptr( FILE * handle, int item )
{
	fprintf(handle,"\n\t\t\t\tpptr[%u]",item);
	return;
}

void	detect_num()
{
	int	i;
	char *	lptr=linebuffer;
	explicite_numbering = 0;
	for (lptr=linebuffer; *lptr != 0; lptr++ )
		if ( *lptr == ',' )
			break;
	if (!( *lptr ))
		return;
	lptr++;
	while ( *lptr == ' ' )
		lptr++;

	if ((*lptr != 'n' )
	&& (*lptr != 'N' ))
		return;
	if ((*(lptr+1) != 'u' )
	&& (*(lptr+1) != 'U' ))
		return;
	if ((*(lptr+2) != 'm' )
	&& (*(lptr+2) != 'M' ))
		return;
	explicite_numbering = 1;

}


int	put_line( FILE * handle )
{
	int	apt=0;
	int	rtp=0;
	int	function_number=0;
	switch ( state_machine ) {
		case	0 :	/* Looking for Version */
			generate_comment( handle, linebuffer );
			if ( detect( "VERSION" ) ) {
				state_machine++;
				detect_num();
				if ( explicite_numbering )
					generate_comment(handle,"Explicite Numbering");
				}
			return( state_machine );

		case	1 :	/* Looking for Runtime */
			generate_comment( handle, linebuffer );
			if ( detect( "RUNTIME" ) )
				state_machine++;
			return( state_machine );


		case	2 :	/* Looking for End     */

			if ( detect( "END" ) ) {
				if ( special ) {
					fprintf(handle,"\tif (fid > function_counter) return(138); else return((*DynamicLibrary->fonction[fid])(pptr));\n");
					}
				else if (function_counter) {
					fprintf(handle,"\t\tdefault\t: return(138);\n\t\t}\n");
					comment_tabulator=1;
					}
				generate_comment( handle, linebuffer );
				state_machine=0;
				}
			else if ( special ) {
				generate_comment( handle, linebuffer );
				if ( explicite_numbering ) {
					if ((function_number = get_explicite()) > function_counter)
						function_counter = function_number;
					}
				else	function_counter++;
				}
			else	{

				/* Generate switch if needed */
				/* ------------------------- */
				if (!( function_counter )) {
					fprintf(handle,"\tswitch ( fid ) {\n");
					comment_tabulator=0;
					}

				/* Detect and Collect Explicite Numbering */
				/* -------------------------------------- */
				if ( explicite_numbering ) {
					if ((function_number = get_explicite()) > function_counter)
						function_counter = function_number;
					}
				else	function_number = function_counter;

				fprintf(handle,"\t\tcase\t%u : ",function_number);
				generate_comment( handle, linebuffer );
				fprintf(handle,"\t\t\treturn((*DynamicLibrary->fonction[%u])(",function_number);
				for (	rtp=0,apt=first_parameter();
					apt != -1;
					apt=next_parameter(),rtp++ ) {

					switch ( (apt & 0x000F) ) {
						case	0 :
							generate_int8(handle,rtp);
							break;
						case	1 :
							generate_int16(handle,rtp);
							break;
						case 0x0080 :
						case 0x0081 :
						case	2 :
						case 0x0082 :
						case	3 :
						case 0x0083 :
							generate_ptr(handle,rtp);
							break;
						}
					if ( apt & 16 )
						fprintf(handle,",");
					}
				fprintf(handle,"));\n");
				/* Post increment the function counter */
				if (!( explicite_numbering ))
					function_counter++;

				}
			return( state_machine );
		}
	return(0);
}


int	convert( char * filename )
{
	FILE *	shandle;
	FILE *	thandle;
	
	strcpy( namebuffer, filename );
	strcat( namebuffer, ".def" );

	if (( shandle = fopen( namebuffer,"r" )) != (FILE *) 0) {

		if ( verbose )
			printf("source file : %s \n",namebuffer);

		if (!( targetname )) {
			strcpy( namebuffer, filename );
			strcat( namebuffer, ".c" );
			}
		else	{
			strcpy( namebuffer, targetname );
			strcat( namebuffer, ".c" );
			}

		if (( thandle = fopen( namebuffer,"w" )) != (FILE *) 0) {

			if ( verbose )
				printf("target file : %s \n",namebuffer);

			generate_header( thandle, filename );

			while ( get_line( shandle ) )
				if (!(put_line( thandle )))
					break;

			generate_footer( thandle, filename );

			fclose( thandle );
			fclose( shandle );
			return( 1 );

			}

		else	{
			fclose(shandle);
			printf("\n*** error creating : %s ***\n",namebuffer);
			return(0);
			}

		}
	else	{
		printf("\n*** error opening : %s ***\n",namebuffer);
		return(0);
		}

}




int	operation( int argc, char * argv[] )
{
	int	argi;
	int	status;
	char *	aptr;
	argvzero = argv[0];
	for ( argi=1; argi < argc; argi++ ) {
		if (!( aptr = argv[argi] ))
			break;

		else  if ( *aptr == '-' ) {
			if (!( option( (aptr+1) )))
				break;
			else	continue;
			}
		else	{
			if (!( convert( aptr ) ))
				break;
			else	continue;
			}			
		}
	return(0);
}

int	main( int argc, char * argv[] )
{

	if ( argc == 1 )
		return(banner(argv[0]));
	else	return(operation(argc,argv));
}

