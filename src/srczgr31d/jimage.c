
#include "wdef.h"

#include <stdio.h>

#include "jguipix.h"
#include "jimage.h"
#include "zglobal.h"
#include "zext.h"
#include "zint.h"
#include "zintctx.h"
#include "ztools.h"
#include "zglobctx.h"
#include "grapil.h"
#include "ztrace.h"

#define CI_MODULE_ID  0x0040

#define MAX_IMAGES 65
// INFO 03052001 about the indexes :
//  indexes 1-->64 are for user usage 
//  index   65     is reserved by zlib for windows generated by the Painter

struct standard_image* bitmaps[MAX_IMAGES];



#ifndef BDA_UNIX
// =================================================================================
// ============================================================================
// = FOR TWIN ONLY                              ===========================
// = For Linux, these functions are in GRAPIL.A =======================
// ================================================================
char      * thispalette=(char *) g_VgaPalette;

// ****************************************************************************
/** load_palette
 * @param filename IN : palette to load in graphic library
 * @return nothing
 * @author 
 */
// ****************************************************************************
void  load_palette( char * filename )
{
  FILE *    handle;
  if ((handle = fopen( filename, "rb" )) != (FILE *) 0) {
    fread( thispalette, 256 * 4, 1, handle);
    fclose( handle );
    vgapalette(thispalette,32,256);
    }
  return;
}

// ****************************************************************************
/** put_palette
 * @param  nothing
 * @return nothing
 * @author 
 */
// ****************************************************************************
void  put_palette()
{
  vgapalette((char *) thispalette,32, 256 );
  return;
}

// ****************************************************************************
/** set_transparence
 * @param  Active
 * @return nothing
 * @author 
 */
// ****************************************************************************
int set_transparence(int IsActive)
{
   return 0;
}

// ================================================================
// ====================================================================
// = FOR TWIN ONLY                              ===========================
// ============================================================================
// =================================================================================
#endif



// ****************************************************************************
/** export_button_bitmap
 * @param index     IN : 1 to MAX_IMAGES
 * @return ptr on standard image or NULL
 * @author 
 */
// ****************************************************************************
struct standard_image* export_button_bitmap(WORD index){

  // Coherence test
  if( (index<1) || (index>MAX_IMAGES) )
    return 0; 

  --index;

  if (bitmaps[index]==0){ 
    return 0;
  }
  else{
    struct standard_image* iptr=bitmaps[index];
    iptr=(struct standard_image*)CloneImage((void*)iptr);
    return iptr;
  }
  return 0;
}

// ****************************************************************************
/** initialise_images
 *  called from zinit() to ensure all entries have been reset to
 *  zero pointers
 */
// ****************************************************************************
VOID  initialise_images()
{
  int i;
  for ( i=0; i < MAX_IMAGES; i++ )
    bitmaps[i] = (struct standard_image *) 0;

  return;
}

// ****************************************************************************
/** zbmp_free
 *
 * @param i     IN : 1 to MAX_IMAGES
 * @return nothing
 * @author 
 */
// ****************************************************************************
VOID zbmp_free(WORD i)
{
MI_TRACE_DCL_TFN("zbmp_free");
struct standard_image * iptr;

  // Coherence test
  if( (i<1) || (i>MAX_IMAGES) )
    {
    MI_TRACE((CI_TRA_F_WARNING,CI_MODULE_ID,TFN,"CE_ERR_BADNOLOG"));
    return;
    }
  else if (!(iptr = bitmaps[i-1]))
    {
    return;
    }
  else  
    {
    DropImage(iptr);//my new
    bitmaps[i-1]=0;//my new
    return;
    }
}

// ****************************************************************************
/** liberate_images
 *  called from zend() to ensure all entries have been released
 */
// ****************************************************************************
VOID  liberate_images()
{
  int i;
  for ( i=0; i < MAX_IMAGES; i++ ){
    if(bitmaps[i]!=0){
    zbmp_free((i+1));
      g_pBmp->BmpKilledByZadapt=i+1;
      }
    }

  return;
}

// ****************************************************************************
/** zbmp_findfreeindex
 *  called to obtain a free index
 *  returns index (1 to MAX_IMAGES) or 0 if no free space
 */
// ****************************************************************************
WORD  zbmp_findfreeindex()
{
WORD i;

  for ( i=0; i < MAX_IMAGES; i++ )
    if (!(bitmaps[i]))
      return i+1; 

return 0;
}

// ****************************************************************************
/** zbmp_load
 * @param entry     IN : 1 to MAX_IMAGES
 * @param filename  IN : 
 * @return 1=OK, 0=NOK
 * @author 
 */
// ****************************************************************************
SWORD zbmp_load(WORD entry,PTRC filename, WORD mode)
{
MI_TRACE_DCL_TFN("zbmp_load");
int result;
struct standard_image* pImage=0;


MI_TRACE((CI_TRA_F_INFO_HIGH,CI_MODULE_ID,TFN,"begin"));

// Coherence test
if ((entry < 1) || (entry > MAX_IMAGES))
   {
   bmp_error_code=CE_ERR_BADNOLOG;
   MI_TRACE((CI_TRA_F_WARNING,CI_MODULE_ID,TFN,"CE_ERR_BADNOLOG"));
   return(0);
   }
else  
   {
   // Release entry
   // ------------
   zbmp_free( entry );

   set_transparence(mode);
   result=LoadImage(filename,1, &pImage);
   set_transparence(FALSE);

   if(result)
      {
      bmp_error_code=result;  
      bitmaps[entry-1]=0;  
      MI_TRACE((CI_TRA_F_INFO_HIGH,CI_MODULE_ID,TFN,"End Bad load"));
      return( 0 );
      }
   else
      {
      bitmaps[entry-1]=(struct standard_image*)(pImage);
      ++g_pBmp->BmpLoaded;
      g_pApp->BitmapCounter++;
      MI_TRACE((CI_TRA_F_INFO_HIGH,CI_MODULE_ID,TFN,"End OK"));
      return( 1  );
      }
   }
  return 0;

}

// ****************************************************************************
/** zwin_bbmp
 * @param bout_type IN : 
 * @param bout_lib  IN : 
 * @param entry     IN : 1 to MAX_IMAGES
 * @param larg      IN : 
 * @return 0=OK, other=ERR
 * @author 
 */
// ****************************************************************************
SWORD   zwin_bbmp(WORD bout_type,PTRC bout_lib,WORD entry,WORD larg)
{
  struct standard_image * iptr;
 
  // Coherence test
  if ((entry < 1) || (entry > MAX_IMAGES))
    return(CE_ERR_BADNOLOG);

  else if (!(iptr = bitmaps[(entry-1)]))
    return CE_ERR_NOLOGID;
  else  return(0);

}

// ****************************************************************************
/** draw_bmp
 * DISPLAY BITMAP AT X,Y
 *
 *   Input:  bitmap handle
 *       x,y,larg, haut, expressed in characters
 *
 *   Output:   0 = No OK now(VAP)
 *        50 = handle incorrect
 *       116   = bitmap not loaded
 */
// ****************************************************************************
SWORD draw_bmp(struct standard_image * iptr,WORD x,WORD y,WORD larg,WORD haut)
{
MI_TRACE_DCL_TFN("draw_bmp");
char    * rptr;
int     gratcol,gratlin;
int     grnbcol,grnblin;
int     srow,trow;
int     transfer=0;
int     tcol=0;

// --------------------------------------------------------------
// - Tests de cohérence
// --------------------------------------------------------------
if (iptr==0)
   return CE_ERR; 
  
if ( (x    == 0) 
   ||(y    == 0) 
   ||(larg == 0) 
   ||(haut == 0) 
   ||(x > screencols) 
   ||(y > screenlins) 
   )
   return CE_ERR;

if ( x+larg-1 > screencols)
   larg = screencols - x + 1;
   
if ( y+haut-1 > screenlins)
   haut = screenlins - y + 1;

MI_TRACE((CI_TRA_F_INFO_LOW,CI_MODULE_ID,TFN,"txt at (%d,%d) on (%d,%d)",x,y,larg,haut));

// --------------------------------------------------------------
// - conversions en coordonnées graphiques  
// --------------------------------------------------------------
  
gratcol = ((x-1)*cellwidth);
gratlin = ((y-1)*cellheight);
grnbcol = (larg*cellwidth);
grnblin = (haut*cellheight);

if ( grnbcol > iptr->columns )
  transfer = iptr->columns;
else  
  transfer = grnbcol;

if (grnbcol>iptr->columns) 
  grnbcol=iptr->columns;
if (grnblin>iptr->rows ) 
  grnblin=iptr->rows;

for (srow=0,trow=0; trow < grnblin; srow++,trow++ ) 
  {
  if ( srow >= iptr->rows ) 
     srow = 0;
  if ((rptr = connect_pixel_row( iptr->storage, srow)) != (char *) 0) 
     {
     for ( tcol=0; tcol < grnbcol; tcol += transfer ) 
        {
        if ((transfer = iptr->columns) > (grnbcol - tcol))  
           transfer = (grnbcol - tcol);
        putzone( gratcol+tcol, gratlin+trow, transfer, 1, rptr );
        }
     }
 }

return CE_OK;
} 

// ****************************************************************************
/** draw_xbmp
 * DISPLAY BITMAP AT X,Y
 *
 *   Input:  
 *       bitmap handle
 *       olarg, ohaut, 
 *       x,y,larg, haut
 *
 *   Output:   0 = No OK now(VAP)
 *        50 = handle incorrect
 *       116   = bitmap not loaded
 */
// ****************************************************************************
SWORD draw_xbmp(struct standard_image * iptr,WORD olarg, WORD ohaut, WORD x,WORD y,WORD larg,WORD haut)
{
MI_TRACE_DCL_TFN("draw_xbmp");
char    * rptr;                           // ligne cible (à afficher)
char    * rptrOri;                        // ligne originale (provenant de l'image)
WORD    grxReq,gryReq,grcxReq,grcyReq;    // coordonnées requises
WORD    grcxOri,grcyOri;                  // coordonnées de l'image origine
WORD    grx   ,gry   ,grcx   ,grcy   ;    // coordonnées finales
WORD    ix,iy;
WORD    * tabx;
WORD    * taby;
unsigned long tmp;
WORD    yfactor;
WORD    Mode;
WORD    SousMode;
WORD    IsFlipFlop;
WORD    IsMirror;
WORD    IsNewLine;
WORD    iy2;
WORD    BgColor;

// --------------------------------------------------------------
// - Tests de cohérence
// --------------------------------------------------------------
if (iptr==0)
   return CE_ERR; 
  
if ( (x    == 0) 
   ||(y    == 0) 
   ||(larg == 0) 
   ||(haut == 0) 
   ||(x > screencols) 
   ||(y > screenlins) 
   )
   return CE_ERR;

if ( x+larg-1 > screencols)
   larg = screencols - x + 1;
   
if ( y+haut-1 > screenlins)
   haut = screenlins - y + 1;

MI_TRACE((CI_TRA_F_INFO_LOW,CI_MODULE_ID,TFN,"txt at (%d,%d) on (%d,%d)",x,y,larg,haut));

// --------------------------------------------------------------
// - Mode de fonctionnement
// -
// - CE_XBMP_MODE_STRETCH : l'image prend toute la place demandée
// -
// - CE_XBMP_MODE_PROP    : Mise à l'échelle en gardant la proportion de l'image
// -                        + centrage 
// -                        + effacement du fond avec NEUTRE
// -
// - CE_XBMP_MODE_EXPERT  : On choisit par champ de bits si on veut
// -                        la mise à l'échelle,
// -                        la conservation des proportions, 
//                          le centrage,  
// -                        l'effacement, 
// -                        l'effet miroir ou flipflop
// -
// - CE_XBMP_MODE_OULESIAN: Utilisation originel du stretch 
// -                        loufoque, bref digne de tonton Oulès
// --------------------------------------------------------------
if ((olarg==0) || (ohaut==0))
   {
   Mode     = (((olarg==0) ? ohaut : olarg) & CE_XBMP_MASK_MODE );
   SousMode = (((olarg==0) ? ohaut : olarg) & CE_XBMP_MASK_SUBMODE );
   if (  (Mode != CE_XBMP_MODE_PROP)
      && (Mode != CE_XBMP_MODE_EXPERT)
      && (Mode != CE_XBMP_MODE_VOID)
      )
      {
      Mode     = CE_XBMP_MODE_STRETCH;   
      SousMode = 0;
      }
   }
else
   {
   Mode     = CE_XBMP_MODE_OULESIAN;
   SousMode = 0;
   }

MI_TRACE((CI_TRA_F_INFO_LOW,CI_MODULE_ID,TFN,"Mode=%04X SousMode=%04X", Mode, SousMode));
   
// --------------------------------------------------------------
// - conversions en coordonnées graphiques  
// - A la fin, gr<x,y,cx,cy>Req sont positionnés à des valeurs valides
// --------------------------------------------------------------

// Valeurs requises
grxReq  = ((x-1)*cellwidth);
gryReq  = ((y-1)*cellheight);
grcxReq = (larg*cellwidth);
grcyReq = (haut*cellheight);

// Taille de l'image d'origine
if (Mode == CE_XBMP_MODE_OULESIAN)
   {
   // On sait pas se que ça peut faire  
   grcxOri = (olarg*cellwidth);
   grcyOri = (ohaut*cellheight);
   if (grcxOri > (WORD)iptr->columns) 
     grcxOri = iptr->columns;
   if (grcyOri > (WORD)iptr->rows ) 
     grcyOri = iptr->rows;
   }
else if ((Mode == CE_XBMP_MODE_EXPERT) && !(SousMode & CE_XBMP_STRETCH))
   {
   // --- Pas de mise à l'échelle
   //     On tronque l'image si nécessaire
   grcxOri = (grcxReq > (WORD)iptr->columns) ? iptr->columns : grcxReq;
   grcyOri = (grcyReq > (WORD)iptr->rows   ) ? iptr->rows    : grcyReq;
   }
else
   {
   // Ca, on sait
   grcxOri = (WORD)iptr->columns;
   grcyOri = (WORD)iptr->rows;
   }

MI_TRACE((CI_TRA_F_INFO_LOW,CI_MODULE_ID,TFN,"grReq at (%d,%d) on (%d,%d)",grxReq,gryReq,grcxReq,grcxReq));
MI_TRACE((CI_TRA_F_INFO_LOW,CI_MODULE_ID,TFN,"grOri on (%d,%d)",grcxOri,grcyOri));

// Prudence, prudence...
if ((grcxOri==0) || (grcyOri==0))
   return CE_ERR;

// --------------------------------------------------------------
// - Taille finale
// - A la fin, grcx et grcy sont positionnés
// --------------------------------------------------------------

if (  ( Mode == CE_XBMP_MODE_PROP)
   || ((Mode == CE_XBMP_MODE_EXPERT) && (SousMode & CE_XBMP_STRETCH) && (SousMode & CE_XBMP_PROP))
   )
   {
   // --- Respect des proportions
   tmp = (unsigned long)grcyOri * (unsigned long)grcxReq / (unsigned long)grcxOri;

   MI_TRACE((CI_TRA_F_INFO_LOW,CI_MODULE_ID,TFN,"tmp=%lu",tmp));

   if (tmp > grcyReq)
      {
      tmp = (unsigned long)grcxOri * (unsigned long)grcyReq / (unsigned long)grcyOri;
      grcx = (WORD)tmp;
      grcy = grcyReq;
      }
   else
      {
      grcx = grcxReq;   
      grcy = (WORD)tmp;
      }
   }
else if ((Mode == CE_XBMP_MODE_EXPERT) && !(SousMode & CE_XBMP_STRETCH))
   {
   // --- Pas de mise à l'échelle
   grcx = grcxOri;   
   grcy = grcyOri;
   }
else
   {
   // --- Toute la surface demandée   
   grcx = grcxReq;   
   grcy = grcyReq;
   }
      
// --------------------------------------------------------------
// - Centrage
// - A la fin, grx et gry sont positionnés
// --------------------------------------------------------------

if (  ( Mode == CE_XBMP_MODE_PROP)
   || ((Mode == CE_XBMP_MODE_EXPERT) && (SousMode & CE_XBMP_CENTER))
   )
   {
   grx = (grcx < grcxReq) ? grxReq + (grcxReq - grcx) / 2 : grxReq ;
   gry = (grcy < grcyReq) ? gryReq + (grcyReq - grcy) / 2 : gryReq ;
   }
else
   {
   grx = grxReq;   
   gry = gryReq;
   }

MI_TRACE((CI_TRA_F_INFO_LOW,CI_MODULE_ID,TFN,"grFin at (%d,%d) on (%d,%d)",grx,gry,grcx,grcy));
   
// --------------------------------------------------------------
// - Allocations en fonction des tailles trouvées
// --------------------------------------------------------------
rptr = allocate( (grcx+1)*sizeof(char) );
if (!rptr)
   return CE_ERR_MEMORY;

tabx = allocate( grcx*sizeof(WORD) );
if (!tabx)
   {
   liberate(rptr);
   return CE_ERR_MEMORY;
   }

taby = allocate( grcy*sizeof(WORD) );
if (!taby)
   {
   liberate(rptr);
   liberate(tabx);
   return CE_ERR_MEMORY;
   }

// --------------------------------------------------------------
// - Calcul de la mise à l'échelle en x et y
// --------------------------------------------------------------
for (ix=0 ; ix<grcx ; ix++)
   {
   tmp = (unsigned long)ix * (unsigned long)grcxOri / (unsigned long)grcx; 
   tabx[ix] = (WORD) tmp;
   }

for (iy=0 ; iy<grcy ; iy++)
   {
   tmp = (unsigned long)iy * (unsigned long)grcyOri / (unsigned long)grcy; 
   taby[iy] = (WORD) tmp;
   }
   
MI_TRACE((CI_TRA_F_DUMP,CI_MODULE_ID,TFN,"tabx", tabx, grcx*sizeof(WORD) ));
MI_TRACE((CI_TRA_F_DUMP,CI_MODULE_ID,TFN,"taby", taby, grcy*sizeof(WORD) ));

// --------------------------------------------------------------
// - Affichage
// --------------------------------------------------------------

// --- Effacement du fond
if ((Mode == CE_XBMP_MODE_VOID) && (SousMode & CE_XBMP_COLOR))
   BgColor = ME_XBMP_VALUECOLOR(SousMode); 
else
   BgColor = CI_COL_NEUTRAL;
    
if (  ( Mode == CE_XBMP_MODE_PROP)
   || ( Mode == CE_XBMP_MODE_VOID)
   || ((Mode == CE_XBMP_MODE_EXPERT) && (SousMode & CE_XBMP_ERASE))
   )
   filzone( grxReq, gryReq, grcxReq, grcyReq, BgColor );

// --- Rapport de transformation en y pour optimisation de l'affichage
yfactor = grcy / grcyOri;
MI_TRACE((CI_TRA_F_INFO_LOW,CI_MODULE_ID,TFN,"linfac=%d",yfactor));

// --- Effets 
IsFlipFlop = ((Mode == CE_XBMP_MODE_EXPERT) && (SousMode & CE_XBMP_FLIPFLOP));
IsMirror   = ((Mode == CE_XBMP_MODE_EXPERT) && (SousMode & CE_XBMP_MIRROR));
MI_TRACE((CI_TRA_F_DEBUG,CI_MODULE_ID,TFN,"Mirror=%d FlipFlop=%d", IsMirror, IsFlipFlop ));

// --- Boucle d'affichage
if (Mode != CE_XBMP_MODE_VOID)
   for (iy=0 ; iy < grcy; iy++ )
      {
      // -- Fabrication d'une nouvelle ligne
      //    Si la ligne est identique à celle utilisée par l'itération précédente, on garde 
      //    Sinon, on en refabrique une nouvelle
      if (IsFlipFlop)
         {
         iy2 = grcy-1-iy;
         IsNewLine = ((iy==0) || (taby[iy2+1]!=taby[iy2]));
         }
      else
         {
         iy2 = iy;
         IsNewLine = ((iy==0) || (taby[iy-1]!=taby[iy]));
         }
            
      if (IsNewLine)
         {
         rptrOri = connect_pixel_row( iptr->storage, taby[iy2]);
         MI_TRACE((CI_TRA_F_DEBUG,CI_MODULE_ID,TFN,"new line taby[%d]==%d -> %08lX", iy2, taby[iy2], (long)rptrOri ));
         if (rptrOri)
            {
            if (IsMirror)
               {
               rptr[0] = rptrOri[tabx[grcx-1]];
               for( ix=0 ; ix<grcx ; ix++)
                  rptr[ix+1]=rptrOri[tabx[grcx-1-ix]];
               }
            else
               {
               rptr[0] = rptrOri[tabx[0]];
               for( ix=0 ; ix<grcx ; ix++)
                  rptr[ix+1]=rptrOri[tabx[ix]];
               }
            }
         }
         
      // --- Affichage de la ligne courante
      //     Lors d'un agrandissement important, on affiche les lignes avec un pixel de décalage
      //     Cela donne souvent un aspect visuel plus agréable
      if (rptrOri)
         {
         if (yfactor > 2)
            putzone( grx, gry+iy, grcx, 1, &rptr[ iy%2 ] );
         else
            putzone( grx, gry+iy, grcx, 1, rptr );
         }
      }

// --------------------------------------------------------------
// - Libérations
// --------------------------------------------------------------
liberate(rptr);
liberate(tabx);
liberate(taby);
return CE_OK;
} 

// ****************************************************************************
/** txt_x_to_gr
 */
// ****************************************************************************
int txt_x_to_gr(WORD tx_larg){
    return (tx_larg)*cellwidth;
}

// ****************************************************************************
/** txt_y_to_gr
 */
// ****************************************************************************
int txt_y_to_gr(WORD tx_haut){
    return (tx_haut)*cellheight;
}

// ****************************************************************************
/** centralize_bitmap
 */
// ****************************************************************************
SWORD centralize_bitmap(PTI_RECTANGLE limit_gr_rect,struct standard_image* iptr,WORD image_tx_larg,WORD image_tx_haut)
{    
char  * rptr;
int   gratcol,gratlin;
int   grnbcol,grnblin;
int   limit_rect_height=0;
int   limit_rect_width=0;
int   srow,trow;
int   transfer=0;
int   tcol=0;  

if(!iptr) 
   return 0;
   
if(image_tx_larg>screencols) 
   image_tx_larg=screencols;
if(image_tx_haut>screenlins) 
   image_tx_haut=screenlins;
   
limit_rect_width =limit_gr_rect->x2 - limit_gr_rect->x1;
limit_rect_height=limit_gr_rect->y2 - limit_gr_rect->y1;

if((!limit_rect_height)||(!limit_rect_width)) 
   return 0;

grnbcol=txt_x_to_gr(image_tx_larg);
grnblin=txt_y_to_gr(image_tx_haut);
    
if ( grnbcol > iptr->rows )//? col>rows
   transfer = iptr->rows;//?
else  
   transfer = grnbcol;//?
    
gratcol=limit_gr_rect->x1;
gratlin=limit_gr_rect->y1;
    
//VAP modif
if(grnbcol>iptr->columns)   
   grnbcol=iptr->columns;
if(grnblin>iptr->rows )     
   grnblin=iptr->rows;
//end modif
    
if(grnblin>(limit_rect_height))
   grnblin=limit_rect_height;
else
   gratlin=limit_gr_rect->y1+((limit_rect_height)-grnblin)/2;

if(grnbcol>(limit_rect_width))
   grnbcol=limit_rect_width;
else
   gratcol=limit_gr_rect->x1+((limit_rect_width)-grnbcol)/2;

for (srow=0,trow=0; trow < grnblin; srow++,trow++ ) 
   {
   if ( srow >= iptr->rows ) 
      srow = 0;
   
   if ((rptr = connect_pixel_row( iptr->storage, srow)) != (char *) 0) 
      {
      for ( tcol=0; tcol < grnbcol; tcol += transfer ) 
         {
         if ((transfer = iptr->columns) > (grnbcol - tcol))
            transfer = (grnbcol - tcol);

         mixzone( gratcol+tcol, gratlin+trow,transfer, 1, rptr );
         }
      }
    }

return 0;
}

// ****************************************************************************
/** zwin_bmp
 * @param entry        IN : 1 to MAX_IMAGES
 * @param x , y        IN : origine d'affichage de l'image 
 * @param larg , haut  IN : largeur d'affichage de l'image
 * @return 0=OK, other=ERR
 * @author 
 */
// ****************************************************************************
SWORD   zwin_bmp( WORD entry, WORD x,WORD y, WORD larg,WORD haut )
{
struct standard_image * iptr;

// Coherence test
if ((entry < 1) || (entry > MAX_IMAGES))
   return CE_ERR_BADNOLOG;
else 
   if (!(iptr = bitmaps[(entry-1)]))
      return CE_ERR_NOLOGID;

return draw_bmp(iptr,x,y,larg,haut);
}

// ****************************************************************************
/** zwin_xbmp
 * @param entry        IN : 1 to MAX_IMAGES
 * @param olarg , oaut IN : taille originale (==0 : pas de mise à l'échelle) 
 * @param x , y        IN : origine d'affichage de l'image 
 * @param larg , haut  IN : largeur d'affichage de l'image
 * @return 0=OK, other=ERR
 * @author 
 */
// ****************************************************************************
SWORD   zwin_xbmp( WORD entry, WORD olarg, WORD ohaut, WORD x,WORD y, WORD larg,WORD haut )
{
struct standard_image * iptr;

// Coherence test
if ((entry < 1) || (entry > MAX_IMAGES))
   return CE_ERR_BADNOLOG;
else 
   if (!(iptr = bitmaps[(entry-1)]))
      return CE_ERR_NOLOGID;

return draw_xbmp(iptr,olarg,ohaut,x,y,larg,haut);
}

