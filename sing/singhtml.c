#ifndef	_singhtml_c
#define	_singhtml_c

private	int	stackitems=0;
private	int	istack[256];
private	int	GenerateDebug=0;
private	int	HtmlPageNumber=0;
private	int	Restriction=0;

extern	char 	LaPaterne[];
extern	char 	StringPaterne[];
#define	_WINDOW_ADJUST 		4
#define	_TABLE_ROW	256
#define	_TABLE_CELL	512
#define	__QUOTE		0x0022
#define	__PERCENT	0x0025

#define	__CopyrightBarSize 24

#define	_DEFAULT_FOOTER 	(char *) 0
#define	_DEFAULT_BANNER		"Generated by <b>Sing</b> and Powered by <b>Abal 3</b> and <b>Bd@Net</b>"
#define	_DEFAULT_COPYRIGHT	"Copyright &copy; 2002,2010 Prologue "
#define	_DEFAULT_BROWSER_SHOW	"Browser"
#define	_DEFAULT_BROWSER_HIDE	"Application"
#define	_DEFAULT_STYLE  	"sing.css"
#define _DEFAULT_TITLE  	"Untitled"

#ifdef	PROLOGUE
#define	_DEFAULT_NAVIGATOR 	"is\\navig\\nv.xp"
#endif
#ifdef	UNIX
#define	_DEFAULT_NAVIGATOR 	"mozilla"
#endif
#ifdef	WIN32
#define	_DEFAULT_NAVIGATOR 	"mozilla"
#endif

private	void	html_unquoted_string( FILE * handle, char * sptr );
private	void	html_submit_field( FILE * h, struct form_item * iptr, char * extra, char * method);
private	void	html_text_widget( FILE * handle,struct form_item * iptr, int mode );

/*	-------------------------------------------------	*/
/*	Metric Management : Pixesl, Points or Millimeters 	*/
/*	-------------------------------------------------	*/
static	char * metric[4] = {	"px","pt","mm","in" };
static	int	metricid=1;
static	int	TextPoints=10;

#define	_metrics metric[metricid]

public	void	set_parametrics( int points, int parametric )
{
	metricid = parametric;
	TextPoints = (10 + points);
	return;
}

public	int	html_scale_quantity( int q )
{
	q *= TextPoints;
	return( ( q / 10 ) );
}

/*	--------------------------------------		*/
/*	Web Server Interface Description Types		*/
/*	--------------------------------------		*/

#define	_WSI_ROOT	0
#define	_WSI_STYLE	1
#define	_WSI_LINK	2
#define	_WSI_IMAGE	3
#define	_WSI_PAGE	4
#define	_WSI_SCRIPT	5
#define	_WSI_SERVICE	6

/* ------------------------------ */
/* table layout control variables */
/* ------------------------------ */
static	int	cellposition[1000];
static	int	cellwidth[1000];
static	int	cellcount=0;
static	int	rowspanning[1000];
static	int	rowposition[1000];
static	int	rowheight[1000];
static	int	rowcount=0;

static	struct	web_server_interface	{
	FILE *	handle;
	char *	name;
	char *	root;
	char *	style;
	int	lock;
	int	validate;
	} WSI	= { 
		(FILE*) 0 ,
		(char *) 0,
		(char *) 0,
		(char *) 0,
		0,0
		};

static	char * nv=_DEFAULT_NAVIGATOR;

static	struct	{
	int	major;
	int	minor;
	} Numerator = {0, 0};

char	hbuffer[512];

struct	sort_control;


struct	sort_cell {
	struct	form_item * widget;
	struct	sort_cell * previous;
	struct	sort_cell * next;
	};

struct	sort_cell *	SortList=(struct sort_cell *) 0;

struct	sort_item {
	struct	form_item * widget;
	struct	sort_item * previous;
	struct	sort_item * next;
	int	rowspan;
	int	colspan;
	};

struct	sort_row	{
	int	y;
	int	h;
	int	columns;
	int	lock;
	struct	sort_row * previous;
	struct	sort_row * next;
	struct	sort_item * first;
	struct	sort_item * last;
	};

struct	sort_control	{
	int		   maxcolumns;
	int		   rowcount;
	int		   formitems;
	struct	sort_row * firstrow;
	struct	sort_row * lastrow;
	struct 	form_item * window;
	} SortMan = { 
		0,0,0,
		(struct sort_row *) 0,
		(struct sort_row *) 0,
		(struct form_item *) 0
		};

public	void	server_interface_record(char * nptr, int type, int method );
private	void	html_scroll_submit_field( FILE * h, struct form_item * iptr, char * extra, char * method, int mode);
private	void	html_open_script( FILE * h, char * nomfic );
private	void	html_close_script( FILE * h, char * nomfic );
public	void	html_rgb_colour( FILE * h, int colourid );
private	void	html_text_style(FILE * h, struct form_item * iptr,int fg, int bg, int mode  );
public	void	close_server_description();

private	void	debug_message(char * mptr)
{
	if ( GenerateDebug ) {
		printf(mptr);
		}
	return;
}

public 	void	html_tag( FILE * h, char * nptr )
{
	fprintf(h,"<%s>",nptr);
	return;
}

public 	void	html_page_tag( FILE * h, char * nptr )
{
	fprintf(h,"<%s style=%cpage-break-before: always;%c>",nptr,__QUOTE,__QUOTE);
	return;
}

private	void	html_open_tag( FILE * h, char * nptr )
{
	fprintf(h,"<%s",nptr);
	return;
}

private	void	html_close_tag( FILE * h, char * nptr )
{
	fprintf(h,">");
	return;
}

public 	void	html_closure( FILE * h, char * nptr )
{
	fprintf(h,"</%s>",nptr);
	return;
}

private	void	html_field( FILE * h, char * nptr, char * vptr )
{
	fprintf(h," %s=",nptr);
	quoted_string(h,vptr);
	return;
}

private	char *	normalise_url( char * sptr )
{
	int	c;
	int	si=0;
	int	di=0;
	char *	rptr;
	if (!( sptr ))
		return( sptr );
	else if (!( rptr = allocate( strlen( sptr ) + 1 ) ))
		return( rptr );
	
	/* step over DOS device prefix */
	/* --------------------------- */
	if ( *(sptr+1) == ':' ) { si+=2; }

	while (1) {
		if (!( c = *(sptr+si)))
			break;
		else if ( c == 0x005C )
			c = '/';
		*(rptr+di) = *(sptr+si);
		di++; si++;
		}

	liberate( sptr );
	return( rptr );
}


private	struct form_item * html_find_window( struct form_item * wptr )
{
	while ( wptr != (struct form_item *) 0 )
		if (( wptr->Contents.style & _FRAME_TYPE) == _WINDOW_FRAME)
			break;
	return( wptr );
}

private	void	html_id( FILE * h, char * nptr)
{
	html_field(h,"id",nptr);
	return;
}

private	void	html_class( FILE * h, char * nptr)
{
	html_field(h,"class",nptr);
	return;
}

private	void	html_radio_id( FILE * h, struct form_item * iptr)
{
	fprintf(h," id=%s%u",iptr->Contents.name,iptr->Contents.radio);
	return;
}

private	void	html_radio_for( FILE * h, struct form_item * iptr)
{
	fprintf(h," for=%s%u",iptr->Contents.name,iptr->Contents.radio);
	return;
}

private	void	html_check_for( FILE * h, struct form_item * iptr)
{
	fprintf(h," for=%s",iptr->Contents.name);
	return;
}

private	int	html_trigger_field( FILE * h, char * nptr, char * vptr )
{
	int	trigger=0;
	fprintf(h," %s=%c",nptr,__QUOTE);
	if (!( vptr ))
		fprintf(h," ");
	else	{
		while ( *vptr != 0 ) {
			if ( *vptr == '&' )
				trigger = *(vptr++);
			else	fprintf(h,"%c",*(vptr++));
			}
		}
	fprintf(h,"%c",__QUOTE);
	return( trigger );
}

private	int	html_trigger_text( FILE * h, char * vptr )
{
	int	trigger=0;
	if (!( vptr ))
		fprintf(h," ");
	else	{
		while ( *vptr != 0 ) {
			if ( *vptr == '&' )
				trigger = *(vptr++);
			else	fprintf(h,"%c",*(vptr++));
			}
		}
	return( trigger );
}

private	void	html_int_field( FILE * h, char * nptr, int v)
{
	fprintf(h," %s=%c%u%c",nptr,__QUOTE,v,__QUOTE);
	return;
}

private	void	html_pt_field( FILE * h, char * nptr, int v)
{
	fprintf(h," %s=%c%u%s%c",nptr,__QUOTE,v,_metrics,__QUOTE);
	return;
}

private	void	html_perc_field( FILE * h, char * nptr, int v)
{
	fprintf(h," %s=%c%u%c%c",nptr,__QUOTE,v,0x0025,__QUOTE);
	return;
}

public	void	html_title(FILE * handle, char * title )
{
	html_tag(handle,"title");
		html_text( handle, title );
	html_closure(handle,"title");
	linefeed(handle);
	return;
}


struct	macro_conversions {
	int	code;
	char *	macro;
	};

#define	MAXMACMAN	25
struct	macro_conversions MacMan[MAXMACMAN] = {
		0x0085 /* 'Ö' */	,	(char *) "&agrave;", 
		0x00A0 /* '†' */	,	(char *) "&aacute;", 
		0x0083 /* 'É' */	,	(char *) "&acirc;" , 
		0x008A /* 'ä' */	,	(char *) "&egrave;", 
		0x0082 /* 'Ç' */	,	(char *) "&eacute;", 
		0x0088 /* 'à' */	,	(char *) "&ecirc;" , 
		0x008D /* 'ç' */	,	(char *) "&igrave;", 
		0x00A1 /* '°' */	,	(char *) "&iacute;", 
		0x008C /* 'å' */	,	(char *) "&icirc;" , 
		0x0095 /* 'ï' */	,	(char *) "&ograve;", 
		0x00A2 /* '¢' */	,	(char *) "&oacute;", 
		0x0093 /* 'ì' */	,	(char *) "&ocirc;" , 
		0x0097 /* 'ó' */	,	(char *) "&ugrave;", 
		0x00A3 /* '£' */	,	(char *) "&uacute;", 
		0x0096 /* 'ñ' */	,	(char *) "&ucirc;", 
		0x0087 /* 'á' */	,	(char *) "&ccedil;",
		0x0081 /* 'Å' */	,	(char *) "&uuml;",
		0x0084 /* 'Ñ' */	,	(char *) "&auml;",
		0x0094 /* 'î' */	,	(char *) "&ouml;",
		0x009A /* 'U' */	,	(char *) "&Uuml;",
		0x008E /* 'A' */	,	(char *) "&Auml;",
		0x0099 /* 'O' */	,	(char *) "&Ouml;",

		/* these are required for XML production but not HTML production */
		/* ------------------------------------------------------------- */
		0x003C /* '<' */	,	(char *) "&lt;",
		0x003E /* '>' */	,	(char *) "&gt;",
		0x0026 /* '&' */	,	(char *) "&amp;"
		};

private	int	MaxMacMan=(MAXMACMAN-3);
public	void	use_html_macros()
{
	MaxMacMan = (MAXMACMAN-3);
	return;
}

public	void	use_xml_macros()
{
	MaxMacMan = MAXMACMAN;
	return;
}


public	char *	html_accent(int c)
{
	int	i;
	for ( i=0; i < MaxMacMan; i++ )
		if ((c & 0x00FF) == (MacMan[i].code & 0x00FF))
			return( MacMan[i].macro );
	return( (char *) 0 );
}


private	int		html_macro(char * sptr)
{
	int	i;
	for ( i=0; i < MaxMacMan; i++ )
		if ( compare( sptr, MacMan[i].macro ) != 0 )
			return( (MacMan[i].code & 0x00FF) );
	return(0);
}


private	char *	old_html_accent(int c)
{
	switch ( (c & 0x00FF) ) {
		case	0x0085 /* 'Ö' */	:	return("&agrave;"); 
		case	0x00A0 /* '†' */	:	return("&aacute;"); 
		case	0x0083 /* 'É' */	:	return("&acirc;" ); 
		case	0x008A /* 'ä' */	:	return("&egrave;"); 
		case	0x0082 /* 'Ç' */	:	return("&eacute;"); 
		case	0x0088 /* 'à' */	:	return("&ecirc;" ); 
		case	0x008D /* 'ç' */	:	return("&igrave;"); 
		case	0x00A1 /* '°' */	:	return("&iacute;"); 
		case	0x008C /* 'å' */	:	return("&icirc;" ); 
		case	0x0095 /* 'ï' */	:	return("&ograve;" ); 
		case	0x00A2 /* '¢' */	:	return("&oacute;" ); 
		case	0x0093 /* 'ì' */	:	return("&ocirc;" ); 
		case	0x0097 /* 'ó' */	:	return("&ugrave;" ); 
		case	0x00A3 /* '£' */	:	return("&uacute;" ); 
		case	0x0096 /* 'ñ' */	:	return("&ucirc;" ); 
		case	0x0087 /* 'á' */	:	return("&ccedil;" ); 
		default				:	return((char *) 0);
		}
}

public	void	convert_html_accents( char **mptr, int mode )
{
	int	macros=0;
	char	macname[32];
	int	c;
	int	i;
	int	j;
	int	m;
	char *	sptr=(char *) 0;
	char *	rptr=(char *) 0;
	char *	wptr=(char *) 0;
	char *	aptr=(char *) 0;
	int	slen=0;
	int	rlen=0;
	int	accents=0;
	if (!( sptr = *mptr ))
		return;
	else if (!(slen = strlen( sptr )))
		return;

	switch ( mode ) {
		case 	2	:
			/* convert from accents to macros */
			/* ------------------------------ */

			/* Calculate new string size ( with macros ) */
			/* ----------------------------------------- */
			for ( accents=0, i=0; i < slen; i++ ) {
				if (!( aptr = html_accent( ( *(sptr+i) & 0x00FF ) ) )) 
					rlen++;
				else	{
					rlen += strlen( aptr );
					accents++;
					}
				}
			if (!( accents ))
				break;
			else	rlen++;
			if (!( rptr = allocate( rlen ) ))
				break;
			else	wptr = rptr;

			for (i=0; i < slen; i++ ) {
				if (!( aptr = html_accent( ( *(sptr+i) & 0x00FF ) ) )) {
					sprintf(wptr,"%c",(*(sptr+i) & 0x00FF));
					wptr++;
					}
				else	{
					sprintf(wptr,"%s",aptr);
					wptr  += strlen( aptr );
					}
				}
			liberate( sptr );
			*mptr = rptr;
			break;

		case	1	:
			/* convert from macros to accents */
			/* Calculate new string size ( with macros ) */
			/* ----------------------------------------- */
			for ( j=0,i=0; i < slen; i++ ) {
				if ((c = *(sptr+i)) == '&' ) {
					for (m=0; m < 31; m++ )
						if ((macname[m] = *(sptr+i+m)) == ';' )
							break;
					if ( macname[m] == ';' )
						m++;
					macname[m] = 0;
					if ((c = html_macro( macname )) != 0 ) {
						i += (m-1);
						macros++;
						}
					}
				*(sptr+j)=c;
				j++;
				}
			if ( macros )
				if ( j < slen )
					*(sptr+j) = 0;

		}
	return;
}

public 	void	html_text( FILE * h, unsigned char * tptr )
{
	char *	sptr;
	int	nbcol;
	int	character;
	if (!( tptr ))
		return;
	for (	nbcol=0; *tptr != 0; tptr++ ) {
		if (( nbcol > 320 ) && ( *tptr == ' ' )) {
			nbcol=0;
			linefeed(h);
			}
		else 	{
			if (( sptr = html_accent((character = (*tptr & 0x00FF)))) != (char *) 0) {
				fprintf(h,"%s",sptr);
				}
			else	{
				if ( character > 127 )
					fprintf(h,"&%d;",character);
				else if ( character == '\r' )
					continue;
				else if ( character == '\n' ) {
					fprintf(h,"\r\n");
					nbcol=0;
					}
				else	fprintf(h,"%c",character);
				}
			nbcol++;
			}
		}
	return;
}

public 	void	html_trigger( FILE * h, unsigned char * tptr )
{
	char *	aptr;
	int	nbcol;
	int	character;
	int	trigger=0;
	if (!( tptr ))
		return;
	for (	nbcol=0; *tptr != 0; tptr++ ) {
		if (( nbcol > 80 )
		&& ( *tptr == ' ' )) {
			nbcol=0;
			linefeed(h);
			}
		else 	{
			if ((aptr = html_accent( (character = ( *tptr & 0x00FF )) )) != (char *) 0)
				fprintf(h,"%s",aptr);
			else if ( character == '&' ) {
				fprintf(h,"<u>");
				trigger=1;
				continue;
				}
			else if ( character > 127 )
				fprintf(h,"&%d;",character);
			else	fprintf(h,"%c",character);
			if ( trigger ) {
				fprintf(h,"</u>");
				trigger=0;
				}
			nbcol++;
			}
		}
	if ( nbcol != 0 )
		linefeed(h);
	return;
}

public	void	html_integer(FILE * handle, int value )
{
	char	muffer[32];
	sprintf(muffer,"%u",value);
	html_text( handle, muffer);
	return;
}



private	void	html_target( FILE * handle, char * target )
{
	html_open_tag(handle,"a");
	html_field(handle,"name",target);
	html_close_tag(handle,"a");
	html_closure(handle,"a");
	linefeed(handle);
	return;
}

private	void	html_anchor( FILE * handle, char * target, char * message )
{
	char	*	nptr;
	if (!(nptr = allocate_string(target)))
		return;
	else if (!( nptr = enforce_extension(nptr,".htm") ))
		return;
	html_open_tag(handle,"a");
	html_field(handle,"href",nptr);
	html_close_tag(handle,"a");
	html_text(handle,message);
	html_closure(handle,"a");
	linefeed(handle);
	return;
}

private	void	html_frame_target_anchor( FILE * handle, char * url, char * target, char * message )
{
	html_open_tag(handle,"a");
	html_field(handle,"href",url);
	html_field(handle,"target",target);
	html_close_tag(handle,"a");
	html_text(handle,message);
	html_closure(handle,"a");
	linefeed(handle);
	return;
}

public	void	html_heading( FILE * h, int size, char * tptr )
{
	char	buffer[16];
	sprintf(buffer,"h%u",size);
	html_open_tag( h, buffer);
	html_field(h,"align","center");
	html_close_tag( h, buffer);		linefeed(h);
	html_text(h,tptr);
	html_closure( h, buffer);		linefeed(h);
	return;
}

public	void	html_normalised_heading( FILE * h, int size, char * tptr )
{
	int	c;
	int	upper=1;
	char	buffer[16];
	sprintf(buffer,"h%u",size);
	html_open_tag( h, buffer);
	html_field(h,"align","center");
	html_close_tag( h, buffer);		linefeed(h);
	while ( *tptr == ' ' ) tptr++;
	while ((c =  *(tptr++)) != 0) {
		if ( upper ) {
			if (( c >= 'a' ) && ( c <= 'z' )) {
				fprintf(h,"%c",(c - ('a' - 'A')));
				}
			else	fprintf(h,"%c",c);
			upper=0;
			}
		else if ( c == '_' ) {
			upper = 1;
			fprintf(h," ");
			}
		else if ( c == ' ' ) {
			upper = 1;
			fprintf(h," ");
			while ( *tptr == ' ' ) tptr++;
			}			
		else	fprintf(h,"%c",c);
		}
	/* html_text(h,tptr); */
	html_closure( h, buffer);		linefeed(h);
	return;
}

private	void	check_open_cell( FILE * handle )
{
	if (!( stackitems )) {
		fprintf(handle,"<p>");
		linefeed(handle);
		}
	else	{
		if (!( istack[stackitems] & _TABLE_ROW )) {
			html_tag(handle,"tr"); linefeed(handle);
			istack[stackitems] |= _TABLE_ROW;
			}
		if (!( istack[stackitems] & _TABLE_CELL )) {
			html_tag(handle,"td"); linefeed(handle);
			istack[stackitems] |= _TABLE_CELL;
			}
		}
	return;
}

public	void	html_image_usemap( FILE * handle, char * mptr )
{
	int	c;
	fprintf(handle," usemap=%c#",__QUOTE);
	while ((c = *(mptr++)) != 0 ) {
		if ( c == ' ' ) c = '_';
		fprintf(handle,"%c",c);
		}
	fprintf(handle,"%c ",__QUOTE);
	return;
}

public	void	html_image( FILE * handle, char * nptr, char * mptr )
{
	html_open_tag(handle,"img");
	html_field(handle,"src", nptr );
	if ( mptr ) { html_image_usemap(handle,mptr); }
	html_field(handle,"alt",nptr);
	html_close_tag(handle,"img");
	linefeed(handle);
	return;
}

public	void	html_resized_image( FILE * handle, char * nptr, char * mptr, int w, int h )
{
	html_open_tag(handle,"img");
	html_field(handle,"src", nptr );
	if ( mptr ) { html_image_usemap(handle,mptr); }
	html_field(handle,"alt",nptr);
	fprintf(handle," width=%u height=%u",w,h);
	html_close_tag(handle,"img");
	linefeed(handle);
	return;
}

public	char * html_numbered_image( FILE * handle, char * nptr, int number , char * mptr, int itype )
{
	int	c;
	char *	sptr;
	char *	xptr;
	if ((sptr = allocate( strlen( nptr ) + 32 )) != (char *) 0) {
		fn_parser(nptr,sptr,0x000F);
		sprintf(sptr,"%s%u",sptr,number);
		xptr = image_extension( itype );		
		sptr = enforce_extension( sptr, xptr );
		html_image( handle, sptr, mptr );
		}
	return(sptr);
}


public	void	html_div(FILE * handle, int align )
{
	switch ( align & 0x0007 ) {
		case	_A_CENTER	:
			fprintf(handle,"<div align=center>");
			break;
		case	_A_LEFT  	:
			fprintf(handle,"<div align=left>");
			break;
		case	_A_RIGHT	:
			fprintf(handle,"<div align=right>");
			break;
		default			:			
			fprintf(handle,"<div>");
			break;
		}
	linefeed(handle);
	return;
}


private	void	html_onhint(FILE * h, char * sptr )
{
	int	c;
	fprintf(h,"_SingOnHint('");
	while ( *sptr != 0 ) {
		if ((c = *(sptr++)) != 0x0027 )
			fprintf(h,"%c",c);
		else	fprintf(h,"%c%c",0x005C,0x0027);
		}
	fprintf(h,"');");
}

private	void	html_widget_hint( FILE * h, struct form_item * iptr, int mode )
{
	char *	sptr;
	char *	nptr;
	if (!( iptr ))
		return;

	switch ((iptr->Contents.style & _FRAME_TYPE)) {
		case	_EDIT_FRAME	:	nptr = "Edit"; 		break;
		case	_BUTTON_FRAME	:	nptr = "Button"; 	break;
		case	_TAB_FRAME	:	nptr = "Tab"; 		break;
		default			:	nptr = "On"; 		break;
		}

	if (!( method_is_valid( (sptr = abal_hint( iptr )) ) ))
		return;
	else if ( *sptr != _UNQUOTED_STRING ) {
		fprintf(h," onmouseover=%c{ %sOver(this); ",__QUOTE,nptr);
		html_onhint(h,sptr);		
		fprintf(h," }%c",__QUOTE);
		fprintf(h," onmouseout=%c{ %sOut(this); }%c",__QUOTE,nptr,__QUOTE);
		if ( mode ) {
			fprintf(h," alt=%c%s%c",__QUOTE,sptr,__QUOTE);
			}
		}
	else 	{
		fprintf(h," onmouseover=%c{ %sOver(this); _SingOnHint('",__QUOTE,nptr);
		html_unquoted_string(h,sptr);
		fprintf(h,"'); }%c",__QUOTE);
		fprintf(h," onmouseout=%c{ %sOut(this); }%c",__QUOTE,nptr,__QUOTE);
		if ( mode ) { 
			fprintf(h," alt=%c%s%c",__QUOTE,sptr,__QUOTE);
			}
		}

}



private	void	html_standard_change( FILE * h, struct form_item * iptr )
{
	char *	sptr;

	if ( method_is_valid( (sptr = iptr->Contents.events->on_lose_focus) ) )
		fprintf(h," onchange=%c{ _SingChainForm('%s.LoseFocus'); }%c",__QUOTE,iptr->Contents.name,__QUOTE);
	return;
}

private	void	html_standard_widget( FILE * h, struct form_item * iptr, int  mode )
{
	char *	sptr;

	html_standard_change( h, iptr );
	html_widget_hint(h,iptr,mode);
	return;
}

public	void	html_bordered_table(FILE * handle, int border, int padding, int spacing )
{
	html_open_tag(handle,"table");
	html_int_field(handle,"cellpadding",padding);
	html_int_field(handle,"cellspacing",spacing);
	html_int_field(handle,"border",border);
	html_close_tag(handle,"table");
	return;
}

private	void	old_html_form_widget( FILE * handle,struct form_item * iptr )
{
	int		bytes=0;
	char	*	sptr;
	int		i;
	int		n;
	int		mode=0;
	int		xfi=0;
	int		f=0;
	int		fields=0;
	int		fieldwidth[_MAX_FORM_FIELDS];
	int		linelength=0;
	int		nblines=0;
	int		fw;
	int		fh;
	int		jsevent=0;
	int		rh;
	
	if ((iptr->Contents.style & _FRAME_TYPE) != _FORM_FRAME)
		return;

	calculate_edit_size( &iptr->Contents );
	calculate_form_lines( iptr, &linelength, &nblines );

	if (!( fields = calculate_form_fields(iptr,fieldwidth,_MAX_FORM_FIELDS,linelength) ))
		return;

	fw = guifontsize(iptr->Contents.font);
	fh = (fw >> 8); fw &= 0x00FF;	
	rh = TextPoints;

	if (( iptr->Contents.events->xo_event & _EVENT_IS_OTHER ) &&  ( method_is_valid( iptr->Contents.events->on_event ) ))
		jsevent=1;
	else	jsevent=0;

	if ( method_is_valid( iptr->Contents.events->on_lose_focus ) )
		jsevent |=2;

	/* --------------------------------------------------------------- */
	/* special hidden input members required for operation ofthe table */
	/* --------------------------------------------------------------- */
	if ( jsevent & 1 ) {
		html_open_tag(handle,"input");
		html_field(handle,"type","hidden");
		fprintf(handle," name=%sEvent",iptr->Contents.name);
		fprintf(handle," value=%c0,0%c",__QUOTE,__QUOTE);
		html_close_tag(handle,"input");
		linefeed(handle);
		}
	if ( jsevent & 2 ) {
		html_open_tag(handle,"input");
		html_field(handle,"type","hidden");
		fprintf(handle," name=%sLoseFocus",iptr->Contents.name);
		fprintf(handle," value=%c0,0%c",__QUOTE,__QUOTE);
		html_close_tag(handle,"input");
		linefeed(handle);
		}

	/* ----------------------------------------- */
	/* Generate the Encompasing Table Components */
	/* ----------------------------------------- */
	html_open_tag(handle,"table");
	html_id(handle,iptr->Contents.name);
	html_int_field(handle,"cellpadding",0);
	html_int_field(handle,"cellspacing",0);
	html_int_field(handle,"border",0);
	html_close_tag(handle,"table");
	html_open_tag(handle,"tr");
	html_id(handle,"tablerow");
	/* html_pt_field(handle,"height",TextPoints); */
	html_close_tag(handle,"tr");
	linefeed(handle);

	/* ------------------------------------------- */
	/* Generate of the Table Column Titles/Headers */
	/* ------------------------------------------- */
	if (( sptr = abal_payload(iptr)) != (char *) 0) {
		for ( n=0,bytes=0,mode=0,i=0; *(sptr+i) != 0; i++ ) {
			if ( *(sptr+i) == '|' ) {
				if ( bytes ) {
					hbuffer[bytes++] = 0;
					html_text(handle,hbuffer);
					bytes=0;
					}
				mode=0;
				}
			else	{
				if (!( mode )) {
					n++;
					linefeed(handle);
					html_open_tag(handle,"th");
					if ( jsevent & 1 ) {
						fprintf(handle," onclick=%c%sClick('%u,0');%c",__QUOTE,iptr->Contents.name,n,__QUOTE);
						}
					html_id(handle,"tabletitle");
					html_close_tag(handle,"th");
					mode=1;
					}
				hbuffer[bytes++] = *(sptr+i);
				}
			}
		if ( bytes ) { 	hbuffer[bytes++] = 0; html_text(handle,hbuffer); bytes=0; }
		}

	/* ------------------------------------------- */
	/* Generation of the Table Data Rows and Cells */
	/* ------------------------------------------- */
	for ( n=0; n < nblines; n++ ) {
		linefeed(handle);
		html_open_tag(handle,"tr");
		switch ( iptr->Contents.align & 0x0007 ) {
			case	0	:
			case	2	: html_class(handle,"tableodd"); break;
			case	1	:
			case	3	: if ( n & 1 )
						html_class(handle,"tableodd");
					  else	html_class(handle,"tableeven");
					  break;
			default		: html_class(handle,"tableodd"); break;
			}	
		html_pt_field(handle,"height",TextPoints);
		html_close_tag(handle,"tr");
		linefeed(handle);

		for ( i=0; i < fields; i++ ) {
			html_open_tag(handle,"td");
			html_pt_field(handle,"width",fieldwidth[i]*fw);
			if ( jsevent & 1 ) {
				fprintf(handle," onclick=%c{ %sClick('%u,%u'); }%c",__QUOTE,iptr->Contents.name,i+1,n+1,__QUOTE);
				fprintf(handle," onmouseover=%cOnOver(this)%c",__QUOTE,__QUOTE);
				fprintf(handle," onmouseout=%cOnOut(this)%c",__QUOTE,__QUOTE);
				}
			html_id(handle,"tablecell");
			html_close_tag(handle,"td");
			if (!( iptr->Contents.events->xo_get_focus & _EVENT_IS_FOCUS )) {
				fprintf(handle,"<widget name=%s(%u,%u)>",iptr->Contents.name,i+1,n+1);
				}
			else	{
				html_open_tag(handle,"input");
				html_field(handle,"type","text");
				if ( jsevent & 2 ) {
					fprintf(handle," onchange=%c{ %sChange('%u,%u'); }%c",__QUOTE,iptr->Contents.name,i+1,n+1,__QUOTE);
					}
				html_widget_hint(handle,iptr,0);
				fprintf(handle," id=%s%u_%u",iptr->Contents.name,i+1,n+1);
				html_int_field(handle,"size",fieldwidth[i]);
				fprintf(handle," name=%c%s(%u,%u)%c",__QUOTE,iptr->Contents.name,i+1,n+1,__QUOTE);
				fprintf(handle," value=%c<widget name=%s(%u,%u)>%c",__QUOTE,iptr->Contents.name,i+1,n+1,__QUOTE);
				html_close_tag(handle,"input");
				}
			linefeed(handle);
			}
		}
	html_closure(handle,"table");
	linefeed(handle);
	return;
}

#include "singwag.c"

private	void	html_form_widget( FILE * handle,struct form_item * iptr )
{
	int		bytes=0;
	char	*	sptr;
	int		i;
	int		n;
	int		mode=0;
	int		xfi=0;
	int		f=0;
	int		fields=0;
	int		fieldwidth[_MAX_FORM_FIELDS];
	int		linelength=0;
	int		nblines=0;
	int		fw;
	int		fh;
	int		jsevent=0;
	int		rh;

	if ((iptr->Contents.style & _FRAME_TYPE) != _FORM_FRAME)
		return;

	calculate_edit_size( &iptr->Contents );
	calculate_form_lines( iptr, &linelength, &nblines );

	if (!( fields = calculate_form_fields(iptr,fieldwidth,_MAX_FORM_FIELDS,linelength) ))
		return;

	fw = guifontsize(iptr->Contents.font);
	fh = (fw >> 8); fw &= 0x00FF;	
	rh = TextPoints;

	jsevent = simple_table_events( handle, iptr );

	/* ----------------------------------------- */
	/* Generate the Encompasing Table Components */
	/* ----------------------------------------- */
	html_open_tag(handle,"table");
	html_id(handle,"tableframe");	
	html_int_field(handle,"cellpadding",0);
	html_int_field(handle,"cellspacing",0);
	html_int_field(handle,"border",1);
	html_close_tag(handle,"table");
	linefeed(handle);

	html_open_tag(handle,"tr");
	html_id(handle,"tablerow");
	/* html_pt_field(handle,"height",TextPoints); */
	html_close_tag(handle,"tr");
	linefeed(handle);

	/* ------------------------------------------- */
	/* Generate of the Table Column Titles/Headers */
	/* ------------------------------------------- */
	if (( sptr = abal_payload(iptr)) != (char *) 0) {
		for ( n=0,bytes=0,mode=0,i=0; *(sptr+i) != 0; i++ ) {
			if ( *(sptr+i) == '|' ) {
				if ( bytes ) {
					hbuffer[bytes++] = 0;
					html_text(handle,hbuffer);
					bytes=0;
					}
				mode=0;
				}
			else	{
				if (!( mode )) {
					n++;
					linefeed(handle);
					html_open_tag(handle,"th");
					fprintf(handle," id=%s%u",iptr->Contents.name,n);
					/*html_id(handle,"tabletitle");*/
					if ( jsevent & 1 ) {
						fprintf(handle," onclick=%c%sClick('%u,0');%c",__QUOTE,iptr->Contents.name,n,__QUOTE);
						}
					html_close_tag(handle,"th");
					mode=1;
					}
				hbuffer[bytes++] = *(sptr+i);
				}
			}
		if ( bytes ) { 	hbuffer[bytes++] = 0; html_text(handle,hbuffer); bytes=0; }
		}

	/* ------------------------------------------- */
	/* Generation of the Table Data Rows and Cells */
	/* ------------------------------------------- */
	for ( n=0; n < nblines; n++ ) {
		linefeed(handle);
		html_open_tag(handle,"tr");
		switch ( iptr->Contents.align & 0x0007 ) {
			case	0	:
			case	2	: html_class(handle,"tableodd"); break;
			case	1	:
			case	3	: if ( n & 1 )
						html_class(handle,"tableodd");
					  else	html_class(handle,"tableeven");
					  break;
			default		: html_class(handle,"tableodd"); break;
			}	
		/* html_pt_field(handle,"height",TextPoints); */
		html_close_tag(handle,"tr");
		linefeed(handle);

		for ( i=0; i < fields; i++ ) {
			html_open_tag(handle,"td");
			/* html_pt_field(handle,"width",fieldwidth[i]*fw); */
			if ( jsevent & 1 ) {
				fprintf(handle," onclick=%c{ %sClick('%u,%u'); }%c",__QUOTE,iptr->Contents.name,i+1,n+1,__QUOTE);
				fprintf(handle," onmouseover=%cOnOver(this)%c",__QUOTE,__QUOTE);
				fprintf(handle," onmouseout=%cOnOut(this)%c",__QUOTE,__QUOTE);
				}
			/* fprintf(handle," id=%s%u_%u",iptr->Contents.name,n,i); */
			/* html_id(handle,"tablecell"); */
			if (!( iptr->Contents.events->xo_get_focus & _EVENT_IS_FOCUS )) {
				fprintf(handle," id=%s%u_%u",iptr->Contents.name,i+1,n+1);
				html_close_tag(handle,"td");
				fprintf(handle,"<widget name=%s(%u,%u)>",iptr->Contents.name,i+1,n+1);
				}
			else	{
				html_close_tag(handle,"td");
				html_open_tag(handle,"input");
				html_field(handle,"type","text");
				if ( jsevent & 2 ) {
					fprintf(handle," onchange=%c{ %sChange('%u,%u'); }%c",__QUOTE,iptr->Contents.name,i+1,n+1,__QUOTE);
					}
				html_widget_hint(handle,iptr,0);
				fprintf(handle," id=%s%u_%u",iptr->Contents.name,i+1,n+1);
				html_int_field(handle,"size",fieldwidth[i]);
				fprintf(handle," name=%c%s(%u,%u)%c",__QUOTE,iptr->Contents.name,i+1,n+1,__QUOTE);
				fprintf(handle," value=%c<widget name=%s(%u,%u)>%c",__QUOTE,iptr->Contents.name,i+1,n+1,__QUOTE);
				html_close_tag(handle,"input");
				}
			linefeed(handle);
			}
		}
	html_closure(handle,"table");
	linefeed(handle);
	return;
}

private	void	html_align(FILE * handle,int v )
{
	switch ( v ) {
		case	1 :	fprintf(handle," align=right "); break;
		case	2 :	fprintf(handle," align=left "); break;
		case	3 :	fprintf(handle," align=center "); break;
		}
	return;
}

public	void	html_open_align(FILE * handle,int v )
{
	html_open_tag(handle,"div");
	html_align(handle,v);
	html_close_tag(handle,"div");
}

public	void	html_close_align(FILE * handle,int v )
{
	fprintf(handle,"</div>");
	return;
}

private	struct form_item * locate_form_widget( struct form_control * fptr, char * nptr )
{
	struct	form_item * iptr=(struct form_item *) 0;
	if (!( nptr ))
		return(iptr);
	for (	iptr=fptr->first;
		iptr != (struct form_item *) 0;
		iptr = iptr->next ) {
		if (!( iptr->Contents.name ))
			continue;
		else if (!( strcmp( iptr->Contents.name, nptr )))
			break;
		}
	return( iptr );
}

private	void	html_unquoted_string( FILE * handle, char * sptr )
{
	int	c;
	struct	form_item * iptr;
	char *	rptr;
	if ( *sptr != _UNQUOTED_STRING )
		return;
	else	sptr++;
	fprintf(handle,"<widget name=");
	rptr = sptr;
	while ( *sptr ) {
		if ( *sptr == '.' )
			break;
		else	fprintf(handle,"%c",*(sptr++));
		}
	c = *sptr;
	*sptr = 0;
	iptr = locate_form_widget( Context.Form, rptr);
	*sptr = c;

	/* -------------------------- */
	/* file widgets need the rest */
	/* -------------------------- */
	if ( iptr != (struct form_item *) 0)
		if  ( is_file_Widget( iptr ) != 0 ) {
			while ( *sptr )
				fprintf(handle,"%c",*(sptr++));

			}
		else if (( iptr->Contents.style & _FRAME_TYPE) == _EDIT_FRAME) {
			fprintf(handle,".buffer");
			}
	fprintf(handle,">");
	return;
}

private	void	html_image_widget(FILE * handle, struct form_item * iptr,int mode)
{
	char	*	sptr;
	if (!( sptr = abal_payload(iptr)))
		return;

	else if ( *sptr != _UNQUOTED_STRING ) {
		server_interface_record(sptr,_WSI_IMAGE,0);
		html_open_tag(handle,"img");
		if ( mode & 3 ) { 
			html_id(handle,iptr->Contents.name); 
			}
		else	{
			fprintf(handle," id=%sData",iptr->Contents.name);
			}
		html_field(handle,"src",sptr);
		html_field(handle,"alt",sptr);
		if ( mode & 4 ) {
			html_int_field(handle,"width",iptr->Contents.w);
			html_int_field(handle,"height",iptr->Contents.h);
			}
		if ( mode & 8 ) {
			html_standard_widget(handle,iptr,0);
			}
		if ( mode & 2 ) {
			if ( iptr->Contents.events->on_event ) {
				html_submit_field(handle,iptr,(char *) 0,"Event");			
				}
			}
		html_close_tag(handle,"img");

		}
	else	{
		html_open_tag(handle,"img");
		if ( mode & 3 ) { html_id(handle,iptr->Contents.name); }
		fprintf(handle," src=%c",__QUOTE);
		html_unquoted_string(handle,sptr);
		fprintf(handle,"%c",__QUOTE);
		fprintf(handle," alt=%c",__QUOTE);
		html_unquoted_string(handle,sptr);
		fprintf(handle,"%c",__QUOTE);
		if ( mode & 4 ) {
			html_int_field(handle,"width",iptr->Contents.w);
			html_int_field(handle,"height",iptr->Contents.h);
			}
		if ( mode & 8 ) {
			html_standard_widget(handle,iptr,0);
			}
		if ( mode & 2 ) {
			if ( iptr->Contents.events->on_event ) {
				html_submit_field(handle,iptr,(char *) 0,"Event");			
				}
			}
		html_close_tag(handle,"img");
		}
	return;
}

private	void	html_submit_field( FILE * h, struct form_item * iptr, char * extra, char * method)
{
	if (!( iptr)) {
		/* --------------------------- */
		/* this is the way it was done */
		/* simple and recomended but . */
		/* Internet Explorer is Shit   */
		/* --------------------------- */
		if ( extra )
			fprintf(h," name=%s%s",iptr->Contents.name,extra);
		else	fprintf(h," name=%s%s",iptr->Contents.name,extra);
		html_field(h,"type","submit");
		html_field(h,"value","Event");
		}
	else if ((( iptr->Contents.style & _FRAME_TYPE) == _BUTTON_FRAME) 
	     &&  (iptr->Contents.datatype == _WIDGET_LOADGO )) {
		if (!( method )) {
			if (!( extra )) {
				fprintf(h," onclick=%c_SingLoadGoForm('%s');%c",__QUOTE,iptr->Contents.name,__QUOTE);
				}
			else	{
				fprintf(h," onclick=%c_SingLoadGoForm('%s%s');%c",__QUOTE,iptr->Contents.name,extra,__QUOTE);
				}
			}
		else if (!( extra) ) {
			fprintf(h," onclick=%c_SingLoadGoForm('%s.%s');%c",__QUOTE,iptr->Contents.name,method,__QUOTE);
			}
		else	{
			fprintf(h," onclick=%c_SingLoadGoForm('%s%s.%s');%c",__QUOTE,iptr->Contents.name,extra,method,__QUOTE);
			}
		}
	else	{
		if (!( method )) {
			if (!( extra )) {
				fprintf(h," onclick=%c_SingChainForm('%s');%c",__QUOTE,iptr->Contents.name,__QUOTE);
				}
			else	{
				fprintf(h," onclick=%c_SingChainForm('%s%s');%c",__QUOTE,iptr->Contents.name,extra,__QUOTE);
				}
			}
		else if (!( extra) ) {
			fprintf(h," onclick=%c_SingChainForm('%s.%s');%c",__QUOTE,iptr->Contents.name,method,__QUOTE);
			}
		else	{
			fprintf(h," onclick=%c_SingChainForm('%s%s.%s');%c",__QUOTE,iptr->Contents.name,extra,method,__QUOTE);
			}
		}
	return;
}

private	void	html_scroll_submit_field( FILE * h, struct form_item * iptr, char * extra, char * method, int mode)
{
	if ( mode & 1 ) {
		fprintf(h," onmousedown=%c%sBarDown(event,1);%c",__QUOTE,iptr->Contents.name,__QUOTE);
		}
	if ( mode & 2 ) {
		fprintf(h," onmousemove=%c%sBarDown(event,0);%c",__QUOTE,iptr->Contents.name,__QUOTE);
		}
	if ( mode & 4 ) {
		fprintf(h," onmouseup=%c%sClickEvent(event);%c",__QUOTE,iptr->Contents.name,__QUOTE);
		}
	fprintf(h," onclick=%c%sClickEvent(event);%c",__QUOTE,iptr->Contents.name,__QUOTE);
	return;
}

private	void	html_scroll_widget(FILE * handle, struct form_item * iptr, int w, int h,int mode)
{
	char * extra="X";
	char * symbol="S";
	int	tvalue;
	char	tstring[16];
	char *	sptr;
	switch ( mode ) {
		case	1	:	symbol="-"; extra = "Up"; break;
		case	2	:	symbol="."; extra = "Bar"; break;
		case	3	:	symbol="+"; extra = "Down"; break;
		}

	html_open_tag(handle,"button");
	html_submit_field(handle,iptr,extra,"Event");
	fprintf(handle," id=%s%s",iptr->Contents.name,extra);
	html_close_tag(handle,"button");
	linefeed(handle);
	html_open_tag(handle,"table");
	html_int_field(handle,"border",0);
	html_pt_field(handle,"width",w);
	html_close_tag(handle,"table");
	html_tag(handle,"tr");
	html_open_tag(handle,"td");
	html_field(handle,"align","center");
	html_pt_field(handle,"height",h);
	html_close_tag(handle,"td");
	html_trigger_text(handle,symbol);
	html_closure(handle,"table");
	html_closure(handle,"button");
	linefeed(handle);
	return;
}

private	void	html_button_widget(FILE * handle, struct form_item * iptr, int w, int h)
{
	int	tvalue;
	char	tstring[16];
	char *	sptr;
	/* check_open_cell(handle); */
	switch ( iptr->Contents.datatype ) {
		case _WIDGET_HYPERLINK :
			if (!( method_is_valid((sptr = iptr->Contents.format)) )) 
				return;
			else if ( iptr->Contents.align & 2 )
				html_open_align(handle,3);
			else	{
				html_open_tag(handle,"div");
				html_align(handle,3);
				html_close_tag(handle,"div");
				}
			html_open_tag(handle,"a");
			if ( *sptr == _UNQUOTED_STRING ) {
				fprintf(handle," href=%c",__QUOTE);
				html_unquoted_string(handle,sptr);
				fprintf(handle,"%c ",__QUOTE);
				}
			else	html_field(handle,"href",iptr->Contents.format);
			/* html_widget_hint(handle,iptr,0); */
			html_close_tag(handle,"a");
			if ( iptr->Contents.align & 1 )
				html_image_widget(handle,iptr,5);
			else	html_text_widget( handle,iptr,1+16 );
			html_closure(handle,"a");
			html_close_align(handle,3);
			linefeed(handle);
			break;

		case _WIDGET_OVERLAY :
		case _WIDGET_CHAIN   :
#ifdef	ABAL32A
		case _WIDGET_TASK    :
#endif
		case _WIDGET_SYSTEM  :
		case _WIDGET_LOADGO  :
		case _WIDGET_MODULE  :
		default		     :
#ifdef	MSII_BUGS
			if (!( method_is_valid((sptr = abal_payload(iptr))) )) 
				return;
			if (!( iptr->Contents.align & 2 )) {
				html_open_tag(handle,"button");
				html_id(handle,iptr->Contents.name);
				html_standard_widget(handle,iptr,0);
				html_submit_field(handle,iptr,(char *) 0,"Event");
				html_close_tag(handle,"button");
				}
			else	{
				html_open_tag(handle,"span");
				html_id(handle,iptr->Contents.name);
				html_standard_widget(handle,iptr,0);
				html_submit_field(handle,iptr,(char *) 0,"Event");
				html_close_tag(handle,"span");
				html_tag(handle,"u");
				}
			if ( iptr->Contents.align & 1 )
				html_image_widget(handle,iptr,4);
			else if ( *sptr == _UNQUOTED_STRING )
				html_unquoted_string(handle,sptr);
			else	html_trigger_text(handle,sptr);
			if (!( iptr->Contents.align & 2 )) 
				html_closure(handle,"button");
			else	{
				html_closure(handle,"u");
				html_closure(handle,"span");
				}
			linefeed(handle);
#else
			if ( iptr->Contents.align & 2 )
				html_open_align(handle,3);
			else	{
				html_open_tag(handle,"div");
				html_align(handle,3);
				html_close_tag(handle,"div");
				}
			if ( iptr->Contents.align & 1 )
				html_image_widget(handle,iptr,8+4+2+1);
			else	html_text_widget( handle,iptr,10+16 );
			html_close_align(handle,3);
			linefeed(handle);
			break;

		case	_TAB_FRAME	:
			html_open_align(handle,3);
			html_text_widget( handle,iptr,10 );
			html_close_align(handle,3);
			linefeed(handle);
			break;

#endif	/* MSIE_BUGGER */

		}
	return;
}

private	void	html_switch_widget(FILE * handle, struct form_item * iptr, int w, int h)
{
	int	tvalue;
	char	tstring[16];
	char *	sptr;
	/* check_open_cell(handle); */
	switch ( iptr->Contents.datatype ) {
		case _WIDGET_HYPERLINK :
			if (!( method_is_valid((sptr = iptr->Contents.format)) )) 
				return;
			else if ( iptr->Contents.align & 2 )
				html_open_align(handle,3);
			else	{
				html_open_tag(handle,"div");
				html_align(handle,3);
				html_close_tag(handle,"div");
				}
			html_open_tag(handle,"a");
			if ( *sptr == _UNQUOTED_STRING ) {
				fprintf(handle," href=%c",__QUOTE);
				html_unquoted_string(handle,sptr);
				fprintf(handle,"%c ",__QUOTE);
				}
			else	html_field(handle,"href",iptr->Contents.format);
			/* html_widget_hint(handle,iptr,0); */
			html_close_tag(handle,"a");
			if ( iptr->Contents.align & 1 )
				html_image_widget(handle,iptr,5);
			else	html_text_widget( handle,iptr,1+16 );
			html_closure(handle,"a");
			html_close_align(handle,3);
			linefeed(handle);
			break;

		case _WIDGET_OVERLAY :
		case _WIDGET_CHAIN   :
#ifdef	ABAL32A
		case _WIDGET_TASK    :
#endif
		case _WIDGET_SYSTEM  :
		case _WIDGET_LOADGO  :
		case _WIDGET_MODULE  :
		default		     :
#ifdef	MSII_BUGS
			if (!( method_is_valid((sptr = abal_payload(iptr))) )) 
				return;
			if (!( iptr->Contents.align & 2 )) {
				html_open_tag(handle,"button");
				html_id(handle,iptr->Contents.name);
				html_standard_widget(handle,iptr,0);
				html_submit_field(handle,iptr,(char *) 0,"Event");
				html_close_tag(handle,"button");
				}
			else	{
				html_open_tag(handle,"span");
				html_id(handle,iptr->Contents.name);
				html_standard_widget(handle,iptr,0);
				html_submit_field(handle,iptr,(char *) 0,"Event");
				html_close_tag(handle,"span");
				html_tag(handle,"u");
				}
			if ( iptr->Contents.align & 1 )
				html_image_widget(handle,iptr,4);
			else if ( *sptr == _UNQUOTED_STRING )
				html_unquoted_string(handle,sptr);
			else	html_trigger_text(handle,sptr);
			if (!( iptr->Contents.align & 2 )) 
				html_closure(handle,"button");
			else	{
				html_closure(handle,"u");
				html_closure(handle,"span");
				}
			linefeed(handle);
#else
			if ( iptr->Contents.align & 2 )
				html_open_align(handle,3);
			else	{
				html_open_tag(handle,"div");
				html_align(handle,3);
				html_close_tag(handle,"div");
				}
			if ( iptr->Contents.align & 1 )
				html_image_widget(handle,iptr,8+4+2+1);
			else	html_text_widget( handle,iptr,10+16 );
			html_close_align(handle,3);
			linefeed(handle);
			break;

		case	_TAB_FRAME	:
			html_open_align(handle,3);
			html_text_widget( handle,iptr,10 );
			html_close_align(handle,3);
			linefeed(handle);
			break;

#endif	/* MSIE_BUGGER */

		}
	return;
}


private	void	html_text_widget( FILE * handle,struct form_item * iptr, int mode )
{
	char *	sptr;
	if ( mode ) {
		html_open_tag(handle,"span");
		html_id(handle,iptr->Contents.name);
		if ( mode & 8 ) {
			html_standard_widget(handle,iptr,0);
			}
		if ( mode & 2 ) {
			if (( iptr->Contents.events->on_event ) 
			||  (( iptr->Contents.style & _FRAME_TYPE) == _TAB_FRAME )) {
				html_submit_field(handle,iptr,(char *) 0,"Event");			
				}
			}
		html_close_tag(handle,"span");
		}
	if ((sptr = abal_payload(iptr)) != (char *) 0) {

		if ( *sptr == _UNQUOTED_STRING )
			html_unquoted_string( handle, sptr );
		else if ( mode & 16 )
			html_trigger_text( handle, sptr );
		else	html_text( handle,sptr);

		}
	if ( mode ) {
		html_closure(handle,"span");	
		}
	return;
}
private	void	html_edit_widget( FILE * handle,struct form_item * iptr )
{
	char *	sptr;
	html_open_tag(handle,"span");
	html_id(handle,iptr->Contents.name);
	html_close_tag(handle,"span");
	fprintf(handle,"<widget name=%s.buffer>",iptr->Contents.name);
	html_closure(handle,"span");	
	return;
}

private	void	generate_html( FILE * handle,struct form_item * iptr )
{
	int	linelength=0;
	int	nblines=0;
	int	tvalue;
	char 	tstring[16];
	int	bytes=0;
	int	i;
	char * sptr;
	int	fh;
	int	fw;
	fw = guifontsize(iptr->Contents.font);
	fh = (fw >> 8); fw &= 0x00FF;	
	switch ((iptr->Contents.style&_FRAME_TYPE)) {	
		case	_FILL_FRAME	:
			check_open_cell(handle);
			break;

		case	_INSET_FRAME	:
			check_open_cell(handle);
			break;

		case	_OUTSET_FRAME	:
			check_open_cell(handle);
			break;

		case	_GROOVE_FRAME	:
			check_open_cell(handle);
			break;

		case	_RIDGE_FRAME	:
			check_open_cell(handle);
			break;

		case	_SELECT_FRAME	:
			/* check_open_cell(handle); */
			html_open_tag(handle,"select");
			html_field(handle,"name",iptr->Contents.name);
			html_close_tag(handle,"select");
			linefeed(handle);
			if ( abal_payload(iptr) ) {
				fprintf(handle,"<widget name=%s>",iptr->Contents.name);
#ifdef	_OLD_HTML_SELECT
				html_tag(handle,"option");
				if (( sptr = abal_payload(iptr)) != (char *) 0) {
					for ( bytes=0,i=0; *(sptr+i) != 0; i++ ) {
						if ( *(sptr+i) == '|' ) {
							if ( bytes ) {
								hbuffer[bytes++] = 0;
								html_text(handle,hbuffer);
								bytes=0;
								}
							linefeed(handle);
			 				html_tag(handle,"option");
							}
						else	{
							hbuffer[bytes++] = *(sptr+i);
							}
						}
					if ( bytes ) {
						hbuffer[bytes++] = 0;
						html_text(handle,hbuffer);
						bytes=0;
						}
					}
#endif	/* OLD_HTML_SELECT */
				linefeed(handle);
				}
			html_closure(handle,"select");
			linefeed(handle);
			break;

		case	_FORM_FRAME	:
			html_form_widget(handle,iptr);
			break;

		case	_EDIT_FRAME	:
			/* check_open_cell(handle); */
			calculate_edit_size( &iptr->Contents );
			calculate_edit_lines( iptr, &linelength, &nblines );
			if ( nblines > 1 ) {
				html_open_tag(handle,"textarea");
				html_field(handle,"name",iptr->Contents.name);
				html_int_field(handle,"cols",linelength);
				html_int_field(handle,"rows",nblines);
				html_close_tag(handle,"textarea");
				linefeed(handle);
				fprintf(handle,"<widget name=%s.buffer>",iptr->Contents.name);
				linefeed(handle);
				html_closure(handle,"textarea");
				linefeed(handle);
				}
			else	{
				html_open_tag(handle,"input");
				if ( iptr->Contents.align & 512 )
					html_field(handle,"type","password");
				else	html_field(handle,"type","text");
				html_field(handle,"name",iptr->Contents.name);
				/* html_int_field(handle,"width",iptr->Contents.w); */
				html_int_field(handle,"size",( iptr->Contents.size != 0 ? iptr->Contents.size : 16 ));
				fprintf(handle," value=%c<widget name=%s.buffer>%c",__QUOTE,iptr->Contents.name,__QUOTE);
				html_close_tag(handle,"input");
				linefeed(handle);
				}
			break;
				
		case	_TEXT_FRAME	:
			/* check_open_cell(handle); */
			switch ( iptr->Contents.font ) {
				case	2 :	html_open_tag(handle,"h5"); 	break;
				case	3 :	html_open_tag(handle,"h4"); 	break;
				case	4 :	html_open_tag(handle,"h3"); 	break;
				case	5 :	html_open_tag(handle,"h2"); 	break;
				case	6 :	html_open_tag(handle,"h1"); 	break;
				default	  :	html_open_tag(handle,"div");	break;
				}
			html_id(handle,iptr->Contents.name);
			html_align(handle, iptr->Contents.align & 7 );
			switch ( iptr->Contents.font ) {
				case	2 :	html_close_tag(handle,"h5"); 	break;
				case	3 :	html_close_tag(handle,"h4"); 	break;
				case	4 :	html_close_tag(handle,"h3"); 	break;
				case	5 :	html_close_tag(handle,"h2"); 	break;
				case	6 :	html_close_tag(handle,"h1"); 	break;
				default	  :	html_close_tag(handle,"div");	break;
				}
			if ( method_is_valid( abal_payload(iptr)  ) )
				html_text( handle,abal_payload(iptr) );
			switch ( iptr->Contents.font ) {
				case	2 :	html_closure(handle,"h5"); 	break;
				case	3 :	html_closure(handle,"h4"); 	break;
				case	4 :	html_closure(handle,"h3"); 	break;
				case	5 :	html_closure(handle,"h2"); 	break;
				case	6 :	html_closure(handle,"h1"); 	break;
				default	  :	html_closure(handle,"div");	break;
				}
			break;

		case	_LINE_FRAME	:
			check_open_cell(handle);
			break;

		case	_IMAGE_FRAME	:
			/* check_open_cell(handle); */
			switch ( iptr->Contents.align & 0x000F ) {
				case	_A_RIGHT	:
				case	_A_LEFT		:
				case	_A_CENTER 	:
				case	_I_TILE		:
				case	_I_MAKEFIT	:
				case	_I_BESTFIT	:
				case	_A_NONE		:
					html_image_widget(handle,iptr,1);
					linefeed(handle);
					break;
				}
			break;

		case	_TAB_FRAME	:
			html_button_widget(handle,iptr,(iptr->Contents.size+2)*fw,fh);
			break;

		case	_SCROLL_FRAME	:
			html_scroll_widget(handle,iptr,iptr->Contents.w,iptr->Contents.w,1);
			html_tag(handle,"br");
			html_scroll_widget(handle,iptr,iptr->Contents.w,iptr->Contents.h-(iptr->Contents.w*2),2);
			html_tag(handle,"br");
			html_scroll_widget(handle,iptr,iptr->Contents.w,iptr->Contents.w,3);
			break;

		case	_BUTTON_FRAME	:
			html_button_widget(handle,iptr,iptr->Contents.w,iptr->Contents.h);
			break;

		case	_GRAPH_FRAME	:
			break;
		case	_SWITCH_FRAME	:
		case	_CHECK_FRAME	:
			/* check_open_cell(handle); */
			html_open_tag(handle,"input");
			html_field(handle,"type","checkbox");
			html_field(handle,"name",iptr->Contents.name);
			fprintf(handle," <widget name=%s> ",iptr->Contents.name);
			html_close_tag(handle,"input");
			if ( method_is_valid( abal_payload(iptr) ) )
				fprintf(handle, " %s ",abal_payload(iptr));
			linefeed(handle);
			break;

		case	_RADIO_FRAME	:
			/* check_open_cell(handle); */
			html_open_tag(handle,"input");
			html_field(handle,"type","radio");
			fprintf(handle," name=%s value=%u ",iptr->Contents.name,iptr->Contents.radio);
			fprintf(handle," <widget name=%s%u> ",iptr->Contents.name,iptr->Contents.radio);
			html_close_tag(handle,"input");
			if ( method_is_valid( abal_payload(iptr) ) )
				fprintf(handle, " %s ",abal_payload(iptr));
			linefeed(handle);
			break;

		case	_WINDOW_FRAME	:
			check_open_cell(handle);
			istack[++stackitems] = _WINDOW_FRAME;
			html_div(handle, iptr->Contents.align & 0x0007 );
			
			html_open_tag(handle,"table"); 
			html_int_field(handle,"border",1);
			html_id(handle,"windowframe");
			html_close_tag(handle,"table");
			linefeed(handle);

			html_tag(handle,"tr");
			html_open_tag(handle,"td");
			html_field(handle,"align","left");
			html_pt_field(handle,"height",20);
			html_class(handle,"windowtitle");
			html_close_tag(handle,"td");
			if ( method_is_valid( abal_payload(iptr) ) )
				html_text(handle,abal_payload(iptr));
			linefeed(handle);

			html_tag(handle,"tr");
			html_open_tag(handle,"td");
			html_field(handle,"align","left");
			html_class(handle,"windowinner");
			html_close_tag(handle,"td");
			linefeed(handle);

			html_open_tag(handle,"table"); 
			html_int_field(handle,"border",GenerateDebug);
			html_pt_field(handle,"cellpadding",1);
			html_int_field(handle,"cellspacing",0);
			html_perc_field(handle,"width",100);
			html_close_tag(handle,"table");
			linefeed(handle);
			break;

		}
	return;
}

public	void	html_forms_national_flag( FILE* handle, struct form_control * fptr, int mode )
{
	char * nptr;
	if ((!( handle )) || (!( fptr ))) { return; }
	html_open_tag(handle,"img");

	if ( mode == -1 ) { 
		mode = fptr->natlang; 
		fprintf(handle," onclick=%c{ _SingChainForm('NatLang'); }%c",__QUOTE,__QUOTE);
		}
	else	fprintf(handle," onclick=%c{ _SingChainForm('NatLang%u'); }%c",__QUOTE,mode+1,__QUOTE);

	switch ( mode ) {
		case	0 : nptr = "/home/abal3/images/en.gif"; break;
		case	1 : nptr = "/home/abal3/images/fr.gif"; break;
		case	2 : nptr = "/home/abal3/images/it.gif"; break;
		case	3 : nptr = "/home/abal3/images/es.gif"; break;
		case	4 : nptr = "/home/abal3/images/de.gif"; break;
		case	5 : nptr = "/home/abal3/images/nl.gif"; break;
		case	6 : nptr = "/home/abal3/images/pt.gif"; break;
		default	  : nptr = "/home/abal3/images/xx.gif"; break;
		}
	html_field(handle,"src",nptr);
	html_field(handle,"alt",nptr);
	html_close_tag(handle,"img");
	server_interface_record(nptr,_WSI_IMAGE,0);
	return;
}

private	void	generate_ahtml( FILE * handle,struct form_item * iptr )
{
	char *	nptr;
	struct	form_control * fptr;
	int	linelength=0;
	int	nblines=0;
	int	tvalue;
	char 	tstring[16];
	int	bytes=0;
	int	i;
	char * sptr;
	int	fh;
	int	fw;
	int	colspan=0;
	fptr = iptr->parent;
	fw = guifontsize(iptr->Contents.font);
	fh = (fw >> 8); fw &= 0x00FF;	
	switch ((iptr->Contents.style&_FRAME_TYPE)) {	
		case	_TAB_FRAME	:
			if ( iptr->Contents.page == HtmlPageNumber ) {
				html_open_tag(handle,"table");
				html_int_field(handle,"border",1);
				fprintf(handle," id=%sPage",iptr->Contents.name);
				html_standard_widget(handle,iptr,0);
				html_close_tag(handle,"table");
				html_tag(handle,"tr");
				html_tag(handle,"td");
				fprintf(handle,"&nbsp;");
				html_closure(handle,"table");
				linefeed(handle);
				html_button_widget(handle,iptr,(iptr->Contents.size+2)*fw,(fh+(fh/4)));
				}
			else	html_button_widget(handle,iptr,(iptr->Contents.size+2)*fw,fh);
			break;

		case	_FILL_FRAME	:
		case	_INSET_FRAME	:
		case	_OUTSET_FRAME	:
		case	_GROOVE_FRAME	:
		case	_RIDGE_FRAME	:
			html_open_tag(handle,"table");
			html_int_field(handle,"border",1);
			html_id(handle,iptr->Contents.name);
			html_close_tag(handle,"table");
			html_tag(handle,"tr");
			html_tag(handle,"td");
			fprintf(handle,"&nbsp;");
			html_closure(handle,"table");
			linefeed(handle);
			break;

		case	_SELECT_FRAME	:
			/* check_open_cell(handle); */
			html_open_tag(handle,"select");
			html_id(handle,iptr->Contents.name);
			html_standard_change(handle,iptr);
			/* html_standard_widget(handle,iptr); */
			html_field(handle,"name",iptr->Contents.name);
			html_close_tag(handle,"select");
			linefeed(handle);
			if ( method_is_valid( abal_payload(iptr) ) ) {
				fprintf(handle,"<widget name=%s>",iptr->Contents.name);
				linefeed(handle);
				}
			html_closure(handle,"select");
			linefeed(handle);
			break;

		case	_FORM_FRAME	:
			html_form_widget(handle,iptr);
			break;

		case	_EDIT_FRAME	:
			/* check_open_cell(handle); */
			calculate_edit_size( &iptr->Contents );
			calculate_edit_lines( iptr, &linelength, &nblines );
			if ( nblines > 1 ) {
				html_open_tag(handle,"textarea");
				html_id(handle,iptr->Contents.name);
				html_standard_widget(handle,iptr,0);
				html_field(handle,"name",iptr->Contents.name);
				html_int_field(handle,"cols",linelength);
				html_int_field(handle,"rows",nblines);
				html_close_tag(handle,"textarea");
				linefeed(handle);
				fprintf(handle,"<widget name=%s.buffer>",iptr->Contents.name);
				linefeed(handle);
				html_closure(handle,"textarea");
				linefeed(handle);
				}
			else	{
				if ( iptr->Contents.events->xo_get_focus & _EVENT_IS_OTHER ) {
					html_open_tag(handle,"input");
					html_id(handle,iptr->Contents.name);
					html_standard_widget(handle,iptr,0);
					if ( iptr->Contents.align & 512 )
						html_field(handle,"type","password");
					else	html_field(handle,"type","text");

					if ( iptr->Contents.datatype == _WIDGET_KONSTANT )
						fprintf(handle," readonly");

					html_field(handle,"name",iptr->Contents.name);
					html_int_field(handle,"size",( iptr->Contents.size != 0 ? iptr->Contents.size : 16 ));
					fprintf(handle," value=%c<widget name=%s.buffer>%c",__QUOTE,iptr->Contents.name,__QUOTE);
					html_close_tag(handle,"input");
					linefeed(handle);
					}
				else	{
					html_edit_widget(handle,iptr);
					linefeed(handle);
					}
				}
			break;
				
		case	_TEXT_FRAME	:
			html_text_widget(handle,iptr,1);
			linefeed(handle);
			break;

		case	_LINE_FRAME	:
			check_open_cell(handle);
			break;

		case	_IMAGE_FRAME	:
			/* check_open_cell(handle); */
			switch ( iptr->Contents.align & 0x000F ) {
				case	_A_RIGHT	:
				case	_A_LEFT		:
				case	_A_CENTER 	:
				case	_I_TILE		:
				case	_I_MAKEFIT	:
				case	_I_BESTFIT	:
				case	_A_NONE		:
					html_image_widget(handle,iptr,1);
					linefeed(handle);
					break;
				}
			break;

		case	_SCROLL_FRAME	:
			html_scroll_widget(handle,iptr,iptr->Contents.w,iptr->Contents.w,1);
			html_tag(handle,"br");
			html_scroll_widget(handle,iptr,iptr->Contents.w,iptr->Contents.h-(iptr->Contents.w*2),2);
			html_tag(handle,"br");
			html_scroll_widget(handle,iptr,iptr->Contents.w,iptr->Contents.w,3);
			break;

		case	_BUTTON_FRAME	:
			html_button_widget(handle,iptr,iptr->Contents.w,iptr->Contents.h);
			break;

		case	_GRAPH_FRAME	:
			break;
		case	_SWITCH_FRAME	:
		case	_CHECK_FRAME	:
			/* check_open_cell(handle); */
			html_open_tag(handle,"input");
			html_id(handle,iptr->Contents.name);
			html_standard_widget(handle,iptr,0);
			html_field(handle,"type","checkbox");
			html_field(handle,"name",iptr->Contents.name);
			fprintf(handle," <widget name=%s> ",iptr->Contents.name);
			html_close_tag(handle,"input");
			html_open_tag(handle,"label");
			html_check_for(handle,iptr);
			fprintf(handle, " id=label%s",iptr->Contents.name);
			html_close_tag(handle,"label");
			if ( method_is_valid( abal_payload(iptr) ) )
				fprintf(handle," %s ",abal_payload(iptr));
			html_closure(handle,"label");
			linefeed(handle);
			break;

		case	_RADIO_FRAME	:
			/* check_open_cell(handle); */
			html_open_tag(handle,"input");
			html_radio_id(handle,iptr);
			html_standard_widget(handle,iptr,0);
			html_field(handle,"type","radio");
			fprintf(handle," name=%s value=%u ",iptr->Contents.name,iptr->Contents.radio);
			fprintf(handle," <widget name=%s%u> ",iptr->Contents.name,iptr->Contents.radio);
			html_close_tag(handle,"input");
			html_open_tag(handle,"label");
			html_radio_for(handle,iptr);
			fprintf(handle, " id=label%s%u",iptr->Contents.name,iptr->Contents.radio);
			html_close_tag(handle,"label");
			if ( method_is_valid( abal_payload(iptr) ) )
				fprintf(handle," %s ",abal_payload(iptr));
			html_closure(handle,"label");
			linefeed(handle);
			break;

		case	_WINDOW_FRAME	:
			check_open_cell(handle);
			istack[++stackitems] = _WINDOW_FRAME;
			html_div(handle, iptr->Contents.align & 0x0007 );
			
			html_open_tag(handle,"table"); 
			html_int_field(handle,"border",1);
			html_id(handle,iptr->Contents.name);
			html_close_tag(handle,"table");
			linefeed(handle);

			html_tag(handle,"tr");
			html_open_tag(handle,"td");
			html_field(handle,"align","left");
			html_pt_field(handle,"height",20);
			html_class(handle,"windowtitle");
			html_close_tag(handle,"td");
			if ( method_is_valid( abal_payload(iptr) ) )
				html_text(handle,abal_payload(iptr));
			linefeed(handle);
			if ( fptr ) {
				if ( fptr->formflags &_MULTILINGUAL ) {
					html_open_tag(handle,"td");
					html_field(handle,"align","center");
					html_pt_field(handle,"width",40);
					html_class(handle,"windowtitle");
					html_close_tag(handle,"td");
					colspan=2;		
					html_forms_national_flag( handle, fptr, -1 );
					linefeed(handle);
					}
				}
			html_closure(handle,"table");
			linefeed(handle);
			html_open_tag(handle,"table"); 
			html_int_field(handle,"border",1);
			fprintf(handle," id=%sbis",iptr->Contents.name);
			html_close_tag(handle,"table");
			linefeed(handle);

			html_tag(handle,"tr");
			html_open_tag(handle,"td");
			if ( colspan ) {
				html_int_field(handle,"colspan",2);
				}
			html_field(handle,"align","left");
			html_class(handle,"windowinner");
			html_close_tag(handle,"td");
			linefeed(handle);

			html_open_tag(handle,"table"); 
			html_int_field(handle,"border",GenerateDebug);
			html_pt_field(handle,"cellpadding",1);
			html_int_field(handle,"cellspacing",0);
			html_perc_field(handle,"width",100);
			html_close_tag(handle,"table");
			html_tag(handle,"tr");
			html_tag(handle,"td");
			linefeed(handle);
			break;

		}
	return;
}

private	void	generate_hidden_html( FILE * handle,struct form_item * iptr )
{
	int	linelength=0;
	int	nblines=0;
	int	fh;
	int	fw;
	fw = guifontsize(iptr->Contents.font);
	fh = (fw >> 8); fw &= 0x00FF;	
	switch ((iptr->Contents.style&_FRAME_TYPE)) {	
		case	_BUTTON_FRAME	:
			calculate_edit_size( &iptr->Contents );
			calculate_edit_lines( iptr, &linelength, &nblines );
			html_open_tag(handle,"input");
			html_field(handle,"type","hidden");
			html_field(handle,"name",iptr->Contents.name);
			fprintf(handle," value=%c%s%c",__QUOTE,iptr->Contents.name,__QUOTE);
			html_close_tag(handle,"input");
			linefeed(handle);
			break;

		case	_RADIO_FRAME	:
		case	_SWITCH_FRAME	:
		case	_CHECK_FRAME	:
		case	_EDIT_FRAME	:
			calculate_edit_size( &iptr->Contents );
			calculate_edit_lines( iptr, &linelength, &nblines );
			html_open_tag(handle,"input");
			html_field(handle,"type","hidden");
			html_field(handle,"name",iptr->Contents.name);
			fprintf(handle," value=%c<widget name=%s>%c",__QUOTE,iptr->Contents.name,__QUOTE);
			html_close_tag(handle,"input");
			linefeed(handle);
			break;
				
		}
	return;
}

public	void	html_paragraph( FILE * handle, char * message )
{
	html_text( handle, message );
	html_tag(handle,"p");
	linefeed(handle);
	return;

}

public	void	html_open_map( FILE * h, char * target )
{
	linefeed(h);
	fprintf(h,"<map name=%c%s%c>",__QUOTE,target,__QUOTE);
	linefeed(h);
	return;
}

public	void	html_close_map( FILE * h)
{
	fprintf(h,"</map>");
	linefeed(h);
	return;
}

public	void	html_area( FILE * handle, char * target, int x, int y, int w, int h, char * alt )
{
	html_open_tag(handle,"area");
	html_field(handle,"shape","rect");
	html_field(handle,"alt",alt);
	fprintf(handle," href=%c#",__QUOTE);
	html_anchor_trigger(handle,target);
	fprintf(handle,"%c coords=%c%u,%u,%u,%u%c>",__QUOTE,__QUOTE,x,y,x+w,y+h,__QUOTE);
	linefeed(handle);
	return;
}

public	void	html_area_href( FILE * handle, char * target, int x, int y, int w, int h, char * alt, char * hptr )
{
	html_open_tag(handle,"area");
	html_field(handle,"shape","rect");
	html_field(handle,"alt",alt);
	fprintf(handle," href=%c%s%c",__QUOTE,hptr,__QUOTE);
	fprintf(handle," coords=%c%u,%u,%u,%u%c>",__QUOTE,x,y,x+w,y+h,__QUOTE);
	linefeed(handle);
	return;
}

public	void	html_tab_area( FILE * handle, char * target, int x, int y, int w, int h, char * alt, int page )
{
	html_open_tag(handle,"area");
	html_field(handle,"shape","rect");
	html_field(handle,"alt",alt);
	fprintf(handle," href=%cpage%u_",__QUOTE,page);
	html_anchor_trigger(handle,target);
	fprintf(handle,"%c coords=%c%u,%u,%u,%u%c>",
			__QUOTE,__QUOTE,x,y,x+w,y+h,__QUOTE);
	linefeed(handle);
	return;
}

public	void	html_button_area( FILE * handle, struct form_item * iptr, int x, int y, int w, int h, char * alt )
{
	html_open_tag(handle,"area");
	html_field(handle,"shape","rect");
	html_field(handle,"alt",alt);
	html_submit_field(handle,iptr,(char *) 0,"Event");			
	fprintf(handle," coords=%c%u,%u,%u,%u%c>",
			__QUOTE,x,y,x+w,y+h,__QUOTE);
	linefeed(handle);
	return;
}

public	void	html_anchor_trigger( FILE * h, char * target )
{
	if (!( target ))
		return;
	for ( ; *target != 0; target++ ) {
		if ( *target == '&' )
			continue;
		else	fprintf(h,"%c",(*target & 0x00FF));
		}
	return;
}

public	void	html_anchor_name( FILE * h, char * target )
{
	fprintf(h,"<a name=%c",__QUOTE);
	html_anchor_trigger(h,target);
	fprintf(h,"%c>",__QUOTE);
	linefeed(h);
	return;
}

public	void	open_html_definition_list( FILE * h)
{
	linefeed(h);
	html_tag(h,"dl");
	linefeed(h);
	return;
}

public	void	html_definition(FILE * h, char * n, char * d )
{
	html_open_tag (h,"dt");   html_class(h,"type"); html_close_tag (h,"dt");  
	if ( n ) {  
		html_anchor_name(h,n);
		html_tag(h,"b"); html_trigger(h,n); html_closure(h,"b"); 
		html_closure(h,"a"); 
		}
	linefeed(h);
	html_open_tag (h,"dd"); html_class(h,"data"); html_close_tag (h,"dd");
 	if (d)	{
		html_text(h,d); 
		html_tag(h,"p");
		}
	linefeed(h);
	return;
}

public	void	html_icon_definition(FILE * h, char * n, char * d, int iwidth, int iheight, int resized )
{
	html_open_tag (h,"dt");   html_class(h,"type"); html_close_tag (h,"dt");  
	if ( n ) {  
		html_anchor_name(h,n);
		if ( resized )	
			html_resized_image(h,n,(char *) 0,iwidth,iheight);
		else	html_image(h,n,(char *) 0 );
		html_closure(h,"a"); 
		}
	linefeed(h);
	html_open_tag (h,"dd"); html_class(h,"data"); html_close_tag (h,"dd");
 	if (d)	{
		html_text(h,d); 
		html_tag(h,"p");
		}
	linefeed(h);
	return;
}

public	void	html_enhanced_icon_definition(FILE * h, char * n, char * d, char * t, int l, int iwidth, int iheight, int resized )
{
	html_open_tag (h,"dt");   html_class(h,"type"); html_close_tag (h,"dt");  
	if ( n ) {  
		html_anchor_name(h,n);
		if ( resized )	
			html_resized_image(h,n,(char *) 0,iwidth,iheight);
		else	html_image(h,n,(char *) 0);
		html_closure(h,"a"); 
		}
	linefeed(h);
	html_open_tag (h,"dd"); html_class(h,"data"); html_close_tag (h,"dd");
 	if (d)	{
		html_text(h,d); 
		html_tag(h,"p");
		}
	if ((t) && ( *t != _UNQUOTED_STRING )) {
		linefeed(h);
		html_tag(h,"p");
		switch ( l ) {
			case	0 : html_text(h,"Click here for more information concerning : "); break;
			case	1 : html_text(h,"Activez ce lien pour plus d'information sur :"  ); break;
			default	  : html_text(h,"Click hrere for more information concerning : "); break;
			}
		html_anchor(h,t,t);
		}
	linefeed(h);
	return;
}

public	void	html_enhanced_definition(FILE * h, char * n, char * d, char * t, int l )
{
	html_open_tag (h,"dt");   html_class(h,"type"); html_close_tag (h,"dt");  
	if ( n ) {  
		html_anchor_name(h,n);
		html_tag(h,"b"); html_trigger(h,n); html_closure(h,"b"); 
		html_closure(h,"a"); 
		}
	linefeed(h);
	html_open_tag (h,"dd"); html_class(h,"data"); html_close_tag (h,"dd");
 	if (d)	{
		html_text(h,d); 
		html_tag(h,"p");
		}
	if ((t) && ( *t != _UNQUOTED_STRING )) {
		linefeed(h);
		html_tag(h,"p");
		switch ( l ) {
			case	0 : html_text(h,"Click here for more information concerning  : "); break;
			case	1 : html_text(h,"Activez ce lien pour plus d'information sur :"  ); break;
			default	  : html_text(h,"Click hrere for more information concerning : "); break;
			}
		html_anchor(h,t,t);
		}
	linefeed(h);
	return;
}

public	void	close_html_definition_list( FILE * h)
{
	linefeed(h);
	html_closure(h,"dl");
	linefeed(h);
	return;
}


public	void	html_close_toc( FILE * handle )
{
	linefeed(handle);
	html_closure(handle,"ol");
	html_closure(handle,"td");
	linefeed(handle);
	html_closure(handle,"table");
	html_closure(handle,"div");
	html_tag(handle,"p");
	linefeed(handle);
	return;
}

public	void	html_add_toc_item( FILE * handle, char * target, char * message )
{
	html_tag(handle,"li");
	html_anchor(handle,target,message);
	html_tag(handle,"br");
	linefeed(handle);
	return;
}

public	void	html_open_toc( FILE * handle )
{
	html_tag(handle,"p");
	
	html_open_tag( handle, "div" );
		html_field( handle, "align", "center" );
		html_close_tag( handle, "div" );
		linefeed(handle);

	html_open_tag( handle, "table" );
		html_field( handle, "class", "TOC" );
		html_close_tag( handle, "table" );
		linefeed(handle);

	html_tag(handle,"tr");
		html_tag(handle,"th");
		html_heading(handle,2,"Table Of Contents");
		linefeed(handle);

	html_tag(handle,"tr");
		html_tag(handle,"td");
		html_tag(handle,"ol");
		linefeed(handle);
	return;
}

public	void	html_open_section( FILE * handle, char * target, char * message,char * iname )
{
	html_target(handle,target);
	linefeed(handle);
	html_tag(handle,"p");
	linefeed(handle);
	html_open_tag( handle, "div" );
		html_field( handle, "align", "center" );
		html_close_tag( handle, "div" );
		linefeed(handle);

	html_open_tag( handle, "table" );
		html_field( handle, "class", "DS" );
		html_close_tag( handle, "table" );
		linefeed(handle);

	html_tag(handle,"tr");
		html_tag(handle,"th");
		html_normalised_heading(handle,2,message);
		linefeed(handle);

	html_tag(handle,"tr");
		html_tag(handle,"td");
		html_tag(handle,"p");
		if ( iname != (char *) 0 ) {
			html_open_tag( handle, "div" );
				html_field( handle, "align", "center" );
				html_close_tag( handle, "div" );
			html_image( handle, iname, message );
			html_closure( handle, "div" );
			html_tag(handle,"p");
			linefeed(handle);
		}
	
	html_tag(handle,"tr");
		html_tag(handle,"td");
		linefeed(handle);

	return;
}

public	void	html_close_section( FILE * handle, char * target, char * message )
{
	linefeed(handle);
	html_closure(handle,"td");
	linefeed(handle);
	html_closure(handle,"table");
	html_closure(handle,"div");
	html_tag(handle,"p"); 
	linefeed(handle);
	return;
}

public	void	flush_to_sector_fit( FILE * handle )
{
	int	i;
	for ( 	i=(ftell( handle ) % 256);
		i < 256; i++ ) {
		linefeed(handle);
		}
	return;
}

public	int	close_html_document( FILE * handle,	char *	footer )
{
	char * sptr;
	int	i;	
	linefeed(handle);
	html_tag(handle,"p");

	if ( not_blank( footer ) ) {
		html_open_tag( handle, "div" );
			html_field( handle, "align", "center" );
			html_close_tag( handle, "div" );
			linefeed(handle);
			html_open_tag( handle, "table" );
			html_field( handle, "class", "CRT" );
			html_close_tag( handle, "table" );
			linefeed(handle);
			html_tag(handle,"tr");
			html_tag(handle,"th");
			html_heading( handle, 3, footer );		

		html_closure(handle,"table");
		html_closure(handle,"div");
		html_tag(handle,"p");
		linefeed(handle);
		}

	/* </BODY> */
	/* ------- */
	html_closure(handle,"body");

	/* </HTML> */
	/* ------- */
	html_closure(handle,"html");	linefeed(handle);

	flush_to_sector_fit(handle);

	return(1);
}

public	int	close_html_frameset( FILE * handle )
{
	char * sptr;
	
	linefeed(handle);

	/* </FRAMESET> */
	/* ----------- */
	html_closure(handle,"body");

	/* </HTML> */
	/* ------- */
	html_closure(handle,"html");	linefeed(handle);

	flush_to_sector_fit(handle);

	return(1);
}

public	void	html_link_style(
		FILE * handle,	
		char * url,
		char * media)

{
	char	*	sptr;

	if (!( sptr = url ))
		sptr = _DEFAULT_STYLE;
	else if ( is_blank( sptr ))
		sptr = _DEFAULT_STYLE;

	html_open_tag(handle,"link");
		html_field(handle,"href",sptr);
		html_field(handle,"type","text/css");
		html_field(handle,"rel","stylesheet");
		if ( not_blank( media ) ) {
			html_field(handle,"media",media);
			}
	html_close_tag(handle,"link");			linefeed(handle);
	return;
}


public	int	html_frame(
		FILE * 	handle,	
		char * 	url,
		char * 	name,
		int	border,
		int	margins,
		int 	scrolling )
{
	html_open_tag(handle,"frame");
	html_field(handle,"name",name);
	html_field(handle,"src",url);
	html_int_field(handle,"marginwidth",margins);
	html_int_field(handle,"marginheight",margins);
	if ( scrolling )
		html_field(handle,"scrolling","yes");
	else	html_field(handle,"scrolling","no");
	if ( border )
		html_field(handle,"frameborder","1");
	else	html_field(handle,"frameborder","0");
	html_close_tag(handle,"frame");
	linefeed(handle);
	return(1);	
}

private	void	html_visual_style( FILE * h )
{
	int	i;

	/* ------------------------ */
	/* Text Font    Style Class */
	/* ------------------------ */
	for (i=1; i < 10; i++ ) {
		fprintf(h,"#textfont%u { font-size: %upt; color: black; }",i,8+(i*2));
		linefeed(h);
		}

	/* ------------------------ */
	/* Frame        Style Class */
	/* ------------------------ */
	fprintf(h,"#outsetframe { border-style: outset; border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#insetframe { border-style: inset; border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#ridgeframe { border-style: ridge; border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#grooveframe { border-style: groove; border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#editframe { border-color: black; border-style: solid; border-width: 1px; background-color: white; color: black; }");
	linefeed(h);
	fprintf(h,"#pageframe { border-style: outset; border-width: 1px; }");
	linefeed(h);

	/* ------------------------ */
	/* Window       Style Class */
	/* ------------------------ */
	fprintf(h,"#windowframe { border-style: outset; border-width: 1px; }");
	linefeed(h);

	fprintf(h,".windowtitle { border-style: inset; border-width: 1px; background-color: navy; color: white; }");
	linefeed(h);

	fprintf(h,".windowinner { border-style: inset; border-width: 1px; background-color: silver; padding: 0; margin: 0; } ");
	linefeed(h);


	/* ------------------------ */
	/* Push Button  Style Class */
	/* ------------------------ */
	fprintf(h,"#buttonframe { border-width: 1px; border-style: outset; color: navy; text-align: center;  }");
	linefeed(h);

	fprintf(h,"#iconframe { border-width: 1px; border-style: inset; color: navy;  }");
	linefeed(h);

	fprintf(h,"#buttonpress { border-width: 1px; border-style: inset; color: navy; }");
	linefeed(h);

	fprintf(h,"#buttonfocus { border-width: 1px; border-style: inset; color: blue; }");
	linefeed(h);

	/* ------------------------ */
	/* Table Widget Style Class */
	/* ------------------------ */
	fprintf(h,"#tableframe { border-style: outset; border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#tabletitle { font-size: %upt; height: %upt; color: black; border-style: inset; border-width: 1px; background-color: navy; color: yellow; }",TextPoints,TextPoints);
	linefeed(h);
	fprintf(h,"#tablecell  { font-size: %upt; height: %upt; color: black; border-style: solid; border-width: 1px; border-color: white; }",TextPoints,TextPoints);
	linefeed(h);
	fprintf(h,"#tablerow   { font-size: %upt; height: %upt; color: black; border-style: none; }",TextPoints,TextPoints);
	linefeed(h);
	fprintf(h,".tableodd   { font-size: %upt; height: %upt; color: black; border-style: none;  background-color: #CCCCCC; }",TextPoints,TextPoints);
	linefeed(h);
	fprintf(h,".tableeven  { font-size: %upt; height: %upt; color: black; border-style: none;  background-color: #DDDDDD; }",TextPoints,TextPoints);
	linefeed(h);

	/* ------------------------ */
	/* Scroll Bar   Style Class */
	/* ------------------------ */
	fprintf(h,"#scrollbutton  { border-style: outset; border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#scrollframe   { border-style: inset;  border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#scrollbar     { border-style: outset; border-width: 1px; }");
	linefeed(h);

	fprintf(h,"#checkframe   { border-style: inset;  border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#radioframe   { border-style: inset;  border-width: 1px; }");
	linefeed(h);
	fprintf(h,"#checklabel   { border-style: none;  }");
	linefeed(h);
	fprintf(h,"#radiolabel   { border-style: none; }");
	linefeed(h);
	return;
}

private	void	html_visual_script( FILE * h )
{
	int	i;

	/* ------------------------ */
	/* Text Font    Style Class */
	/* ------------------------ */
	for (i=1; i < 10; i++ ) {
		switch ( (i % 4)) {
			case	0 :	fprintf(h,"textfont%u = %c font-size: %upt; %c;",i,__QUOTE,html_scale_quantity(8+(i*2)),__QUOTE);	break;
			case	1 :	fprintf(h,"textfont%u = %c font-size: %upt; %c;",i,__QUOTE,html_scale_quantity(8+(i*2)),__QUOTE);	break;
			case	2 :	fprintf(h,"textfont%u = %c font-size: %upt; %c;",i,__QUOTE,html_scale_quantity(8+(i*2)),__QUOTE);	break;
			case	3 :	fprintf(h,"textfont%u = %c font-size: %upt; %c;",i,__QUOTE,html_scale_quantity(8+(i*2)),__QUOTE);	break;
			}
		linefeed(h);
		}

	/* ------------------------ */
	/* Frame        Style Class */
	/* ------------------------ */
	fprintf(h,"outsetframe = %c border-style: outset; border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"insetframe = %c border-style: inset; border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"ridgeframe = %c border-style: ridge; border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"grooveframe = %c border-style: groove; border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"editframe = %c border-color: black; border-style: solid; border-width: 1px; background-color: white; color: black; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"pageframe = %c border-style: outset; border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);

	/* ------------------------ */
	/* Window       Style Class */
	/* ------------------------ */
	fprintf(h,"windowframe = %c border-style: outset; border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);

	fprintf(h,"windowtitle = %c border-style: inset; border-width: 1px; background-color: navy; color: white; %c;",__QUOTE,__QUOTE);
	linefeed(h);

	fprintf(h,"windowinner = %c border-style: inset; border-width: 1px; background-color: silver; padding: 0; margin: 0; %c; ",__QUOTE,__QUOTE);
	linefeed(h);


	/* ------------------------ */
	/* Push Button  Style Class */
	/* ------------------------ */
	fprintf(h,"buttonframe = %c border-width: 1px; border-style: outset; color: navy; text-align: center;  %c;",__QUOTE,__QUOTE);
	linefeed(h);

	fprintf(h,"iconframe = %c border-width: 1px; border-style: inset; color: navy;  %c;",__QUOTE,__QUOTE);
	linefeed(h);

	fprintf(h,"buttonpress = %c border-width: 1px; border-style: inset; color: navy; %c;",__QUOTE,__QUOTE);
	linefeed(h);

	fprintf(h,"buttonfocus = %c border-width: 1px; border-style: inset; color: blue; %c;",__QUOTE,__QUOTE);
	linefeed(h);

	/* ------------------------ */
	/* Table Widget Style Class */
	/* ------------------------ */
	fprintf(h,"tablefont  = %c font-size: %upt; height: %upt; color: black; %c;",__QUOTE,TextPoints,TextPoints,__QUOTE);
	linefeed(h);
	fprintf(h,"tableframe = %c border-style: solid; border-color: white; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"tabletitle = %c border-width: 1px; border-style: inset; background-color: navy; color: yellow; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"tablecell  = %c border-style: solid; border-width: 1px; border-color: white; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"tablerow   = %c border-style: solid; border-color: white; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"tableodd   = %c border-style: none;  background-color: #CCCCCC; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"tableeven  = %c border-style: none;  background-color: #DDDDDD; %c;",__QUOTE,__QUOTE);
	linefeed(h);

	/* ------------------------ */
	/* Scroll Bar   Style Class */
	/* ------------------------ */
	fprintf(h,"scrollbutton  = %c border-style: outset; border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"scrollframe   = %c border-style: inset;  border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"scrollbar     = %c border-style: outset; border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);

	fprintf(h,"checkframe   = %c border-style: inset;  border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"radioframe   = %c border-style: inset;  border-width: 1px; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"checklabel   = %c border-style: none;  %c;",__QUOTE,__QUOTE);
	linefeed(h);
	fprintf(h,"radiolabel   = %c border-style: none; %c;",__QUOTE,__QUOTE);
	linefeed(h);
	return;
}

private	void	html_open_script( FILE * h, char * nomfic )
{
	html_open_tag(h,"script");
	html_field( h, "type", "text/javascript" );
	if ( nomfic ) { html_field( h, "src", nomfic ); }
	html_close_tag(h,"script");
	if (!( nomfic )) {
		linefeed(h);
		fprintf(h,"<!--  to hide script contents from old browsers");
		}
	linefeed(h);
	return;
}

private	void	html_close_script( FILE * h, char * nomfic )
{
	if (!( nomfic )) {
		linefeed(h);
		fprintf(h,"// end browser script content hiding  -->");
		}
	linefeed(h);
	html_closure(h,"script");
	linefeed(h);
}

private	void	html_screen_style( FILE * h )
{
	html_open_script(h,"sing.js");	
	server_interface_record( "sing.js", _WSI_SCRIPT, 0);
	/*  html_visual_script(h); generates default javascript widget constants */
	html_close_script(h,"sing.js");

	html_open_tag(h,"link");
		html_field(h,"href","sing.css");
		html_field(h,"type","text/css");
		html_field(h,"rel","stylesheet");
	html_close_tag(h,"link");
	linefeed(h);

	server_interface_record( "sing.css", _WSI_STYLE, 0 );
	return;
}

private	void	html_print_style( FILE * h )
{
	html_open_tag(h,"style");
	html_field(h,"media","screen");
	html_field(h,"type","text/css");
	html_close_tag(h,"style");
	linefeed(h);
	html_visual_style(h);	
	html_closure(h,"style");
	linefeed(h);
	return;
}

public	void	html_rgb_colour( FILE * h, int colourid )
{
	int	rvalue=0;
	int	gvalue=0;
	int	bvalue=0;
	get_rgb_values(colourid,&rvalue,&gvalue,&bvalue );
	if ((!( rvalue )) && (!( gvalue )) && (!( bvalue )))
		fprintf(h,"transparent;");
	else	fprintf(h,"#%02.2X%02.2X%02.2X;",(rvalue&0x00FF),(gvalue&0x00FF),(bvalue&0x00FF));
	return;
}

private	void	html_css_absolute(FILE * handle, int left, int top, int w, int h )
{
	fprintf(handle,"position: absolute; left: %u%s; top: %u%s; width: %u%s; height: %u%s; ",
			left,_metrics,top,_metrics,w,_metrics,h,_metrics);
	return;
}


private	void	html_widget_size(struct form_item * wptr, struct window_control * Window, int alt )
{
	int 	fw; 
	int	fh;
	struct	form_item * iptr=(struct form_item *) 0;
	Window->x = Window->y = Window->w = Window->h = 0;
	if (!( wptr ))
		return;
	switch ((wptr->Contents.style & _FRAME_TYPE )) {
		case	_SELECT_FRAME	:
			fw = guifontsize(wptr->Contents.font);
			fh = (fw >> 8); fw &= 0x00FF;	
			Window->x = wptr->Contents.x;
			Window->w = wptr->Contents.w;
			Window->y = wptr->Contents.y;
			Window->h = fh;
			break;
		case	_TAB_FRAME	:
			fw = guifontsize(wptr->Contents.font);
			fh = (fw >> 8); fw &= 0x00FF;	
			if (!( alt )) {
				calculate_edit_size( &wptr->Contents );
				Window->x = (wptr->Contents.x + wptr->Contents.adjust);
				for (	iptr=wptr->next;
					iptr != (struct form_item *) 0;
					iptr = iptr->next ) {
					if ((iptr->Contents.style & _FRAME_TYPE ) == _TAB_FRAME)
						break;
					}
				if ( iptr ) 
					Window->w = ((iptr->Contents.x + iptr->Contents.adjust) - Window->x);
				else	Window->w = ((wptr->Contents.size+2) * fw);
				if ( wptr->Contents.page != HtmlPageNumber )
					Window->h = (fh+(fh/2)-1);
				else	Window->h = (fh+(fh/2)-1/*+(fh/4)*/);
				Window->y = wptr->Contents.y;
				}
			else	{
				Window->x = wptr->Contents.x;
				Window->w = wptr->Contents.w;
				Window->y = (wptr->Contents.y+(fh+(fh/2)));
				Window->h = (wptr->Contents.h-(fh+(fh/2)));
				}
			break;
		default			:
			Window->x = wptr->Contents.x;
			Window->w = wptr->Contents.w;
			Window->y = wptr->Contents.y;
			Window->h = wptr->Contents.h;
		}
	return;
}

private	void	html_widget_scale(struct form_item * iptr, struct window_control * Widget, int alt )
{
	html_widget_size(iptr,Widget,alt);
	Widget->w *= TextPoints; Widget->w /= 10;
	Widget->h *= TextPoints; Widget->h /= 10;
	Widget->x *= TextPoints; Widget->x /= 10;
	Widget->y *= TextPoints; Widget->y /= 10;
	return;
}

private	void	html_text_style(FILE * h, struct form_item * iptr,int fg, int bg, int mode  )
{
	int	fw;
	int	fh;

	if ( mode ) {
		if ( iptr )
			simple_styled_text_font(h, iptr->Contents.font );
		}

	if ( iptr->Contents.align & _A_BOLD )
		fprintf(h," font-weight: bold;");
	if ( iptr->Contents.align & _A_SHADOW )
		fprintf(h," font-style: italic;");

	if ( iptr->Contents.align & _A_LINE )
		if (( iptr->Contents.style & _FRAME_TYPE ) != _EDIT_FRAME)
			fprintf(h," text-decoration: underline;");

	fprintf(h," vertical-align: middle;");

	fprintf(h," text-align: ");

	switch ( iptr->Contents.align & 7 ) {
		case	1 :	fprintf(h," right; "); 	 break;
		case	2 :	fprintf(h," left; "); 	 break;
		case	3 :	fprintf(h," center; ");  break;
		case	4 :	fprintf(h," justify; "); break;
		default	  :	fprintf(h," left; "); 	 break;
		}

	fprintf(h," color: "); html_rgb_colour(h,fg);
	if ( bg ) {
		fprintf(h," background-color: "); html_rgb_colour(h,bg);
		}
	return;
}

private	void	html_widget_style(FILE * h, struct form_item * iptr,struct form_item * wptr  )
{
	int	fg;
	int	bg;
	struct window_control Widget;
	if (!( iptr )) 	return;
	else	{

		html_widget_scale(iptr,&Widget,0);

		fg = (iptr->Contents.colour & 0x00FF);
		bg = ((iptr->Contents.colour & 0xFF00) >> 8);

		if (( iptr->Contents.style & _FRAME_TYPE ) == _SCROLL_FRAME)
			fprintf(h,"#%sBar { ",iptr->Contents.name);
		else if (( iptr->Contents.style & _FRAME_TYPE ) == _RADIO_FRAME)
			fprintf(h,"#%s%u { ",iptr->Contents.name,iptr->Contents.radio);
		else 	fprintf(h,"#%s { ",iptr->Contents.name);

		switch (( iptr->Contents.style & _FRAME_TYPE )) {

			case	_TAB_FRAME	:
				if ( iptr->Contents.page != HtmlPageNumber )
					fprintf(h," class: buttonframe; ");
				else	fprintf(h," class: buttonfocus; ");
				break;

			case	_BUTTON_FRAME	:
				if ( iptr->Contents.align & 1 )
					fprintf(h," class: iconframe;");
				else	fprintf(h," class: buttonframe;");

				fprintf(h," vertical-align: middle; ");
				break;

			case	_EDIT_FRAME	:
				fprintf(h," class: editframe; ");
				if (!( iptr->Contents.events->xo_get_focus & _EVENT_IS_FOCUS ))
					html_text_style(h,iptr,fg,bg,0);

				break;

			case	_TEXT_FRAME	:

				fprintf(h," class: textfont%u;",iptr->Contents.font);
				html_text_style(h,iptr,fg,bg,0);
				break;


			case	_OUTSET_FRAME	:
				fprintf(h," class: outsetframe; ");
				break;

			case	_INSET_FRAME	:
				fprintf(h," class: insetframe; ");
				break;

			case	_RIDGE_FRAME	:
				fprintf(h," class: ridgeframe; ");
				break;

			case	_GROOVE_FRAME	:
				fprintf(h," class: grooveframe; ");
				break;

			case	_FORM_FRAME	:
				fprintf(h," class: tableframe; ");
				break;

			case	_WINDOW_FRAME	:
				fprintf(h," class: windowframe; ");
				break;

			case	_CHECK_FRAME	:
				fprintf(h," class: checkframe; ");
				break;

			case	_RADIO_FRAME	:
				fprintf(h," class: radioframe; ");
				break;
			case	_SWITCH_FRAME	:
				fprintf(h," class: switchframe; ");
				break;
			}

		switch (( iptr->Contents.style & _FRAME_TYPE )) {

			case	_RADIO_FRAME	:
			case	_CHECK_FRAME	:

				if (!( wptr ))
					html_css_absolute(h,Widget.x,Widget.y,Widget.h,Widget.h);
				else	html_css_absolute(h,Widget.x+wptr->Contents.x,Widget.y+wptr->Contents.y,Widget.h,Widget.h);
				fprintf(h,"}");
				linefeed(h);

				if (( iptr->Contents.style & _FRAME_TYPE ) != _RADIO_FRAME)
					fprintf(h,"#label%s { ",iptr->Contents.name);
				else	fprintf(h,"#label%s%u { ",iptr->Contents.name,iptr->Contents.radio);

				if (!( wptr ))
					html_css_absolute(h,Widget.x+(Widget.h*2),Widget.y,Widget.w-(Widget.h*2),Widget.h);
				else	html_css_absolute(h,Widget.x+(Widget.h*2)+wptr->Contents.x,Widget.y+wptr->Contents.y,Widget.w-(Widget.h*2),Widget.h);

				fprintf(h," class: textfont%u; ",iptr->Contents.font);

				break;

			case	_SCROLL_FRAME	:

				fprintf(h," class: scrollframe; ");

				if (!( wptr ))
					html_css_absolute(h,Widget.x,Widget.y+Widget.w,Widget.w,Widget.h-(Widget.w*2));
				else	html_css_absolute(h,Widget.x+wptr->Contents.x,Widget.y+wptr->Contents.y+Widget.w,Widget.w,Widget.h-(Widget.w*2));
				fprintf(h,"}");
				linefeed(h);

				fprintf(h,"#%sUp { ",iptr->Contents.name);

				fprintf(h," class: scrollbutton; ");

				if (!( wptr ))
					html_css_absolute(h,Widget.x,Widget.y,Widget.w,Widget.w);
				else	html_css_absolute(h,Widget.x+wptr->Contents.x,Widget.y+wptr->Contents.y,Widget.w,Widget.w);

				fprintf(h,"}");
				linefeed(h);

				fprintf(h,"#%sDown { ",iptr->Contents.name);

				fprintf(h," class: scrollbutton; ");

				if (!( wptr ))
					html_css_absolute(h,Widget.x,Widget.y+(Widget.h-Widget.w),Widget.w,Widget.w);
				else	html_css_absolute(h,Widget.x+wptr->Contents.x,Widget.y+wptr->Contents.y+(Widget.h-Widget.w),Widget.w,Widget.w);

				break;

			case	_TAB_FRAME	:
				if (!( wptr ))
					html_css_absolute(h,Widget.x,Widget.y,Widget.w,Widget.h);
				else	html_css_absolute(h,Widget.x+wptr->Contents.x,Widget.y+wptr->Contents.y,Widget.w,Widget.h);

				if ( iptr->Contents.page != HtmlPageNumber )
					break;			

				fprintf(h,"}");
				linefeed(h);

				fprintf(h,"#%sPage { ",iptr->Contents.name);
				fprintf(h," class: pageframe; ");

				html_widget_scale(iptr,&Widget,1);

			default			:
				if (!( wptr ))
					html_css_absolute(h,Widget.x,Widget.y,Widget.w,Widget.h);
				else	html_css_absolute(h,Widget.x+wptr->Contents.x,Widget.y+wptr->Contents.y,Widget.w,Widget.h);
			}
		}
	fprintf(h,"}");
	linefeed(h);
	return;
}

private	void	html_form_style(FILE * h, struct form_control * fptr )
{
	struct	form_item * iptr;
	struct	form_item * wptr=(struct form_item *) 0;
	html_open_tag(h,"style");
	html_field(h,"type","text/css");
	html_field(h,"media","screen");
	html_close_tag(h,"style");
	linefeed(h);
	for (	iptr=fptr->first;
		iptr != (struct form_item *) 0;
		iptr = iptr->next ) {
		if ((!( iptr->Contents.w  ))
		||  (!( iptr->Contents.h  )))
			continue;
		else if (iptr->Contents.events->xo_show & _EVENT_IS_COND )
			continue;
		else if (!( HtmlPageNumber ))
			html_widget_style(h,iptr,wptr);
		else if (!( iptr->Contents.page ))
			html_widget_style(h,iptr,wptr);
		else if (( iptr->Contents.style & _FRAME_TYPE) == _TAB_FRAME)
			html_widget_style(h,iptr,wptr);
		else if ( iptr->Contents.page == HtmlPageNumber )
			html_widget_style(h,iptr,wptr);
		if (( iptr->Contents.style & _FRAME_TYPE) == _WINDOW_FRAME)
			wptr = iptr;
		}
	html_closure(h,"style");
	linefeed(h);
	html_open_tag(h,"style");
	html_field(h,"type","text/css");
	html_field(h,"media","print");
	html_close_tag(h,"style");
	linefeed(h);
	for (	wptr=(struct form_item*) 0,
		iptr=fptr->first;
		iptr != (struct form_item *) 0;
		iptr = iptr->next ) {
		if ((!( iptr->Contents.w  ))
		||  (!( iptr->Contents.h  )))
			continue;
		else if (iptr->Contents.events->xo_show & _EVENT_IS_COND )
			continue;
		else if (!( HtmlPageNumber ))
			html_widget_style(h,iptr,wptr);
		else if (!( iptr->Contents.page ))
			html_widget_style(h,iptr,wptr);
		else if (( iptr->Contents.style & _FRAME_TYPE) == _TAB_FRAME)
			html_widget_style(h,iptr,wptr);
		else if ( iptr->Contents.page == HtmlPageNumber )
			html_widget_style(h,iptr,wptr);
		if (( iptr->Contents.style & _FRAME_TYPE) == _WINDOW_FRAME)
			wptr = iptr;
		}
	html_closure(h,"style");
	linefeed(h);
	return;
}



public	int	html_frameset(
		FILE * handle,	
		int	direction,
		char *	descriptor )
{
	html_open_tag(handle,"frameset");
	if (!( direction ))
		html_field(handle,"cols",descriptor);
	else	html_field(handle,"rows",descriptor);
	html_close_tag(handle,"frameset");
	linefeed(handle);
	return(1);
}

#include "singdhtm.c"

private	void	html_form_script( FILE * h, struct form_control * fptr, int xjs )
{
	FILE *	hh;
	int	focusitems=0;
	int	recalculate=0;
	struct window_control Widget;
	struct	form_item * iptr;
	struct	form_item * wptr=(struct form_item *) 0;
	char 	*	jsnom;
	char	*	nptr;

	if ( xjs ) {
		switch ( fptr->natlang ) {
			case	0 : nptr = "en"; break;
			case	1 : nptr = "fr"; break;
			case	2 : nptr = "it"; break;
			case	3 : nptr = "es"; break;
			case	4 : nptr = "de"; break;
			case	5 : nptr = "nl"; break;
			case	6 : nptr = "pt"; break;
			default	  : nptr = "xx"; break;
			}

		if (!( jsnom = allocate( strlen( nptr ) + strlen( fptr->prodname ) + 16 ) ))
			return;
		else	sprintf(jsnom,"%s/%s",nptr,fptr->prodname);

		if (!( jsnom = enforce_extension( jsnom, JS_EXTENSION )))
			return;
		}

	/* Open External Script Declaration */
	/* -------------------------------- */
	html_open_script(h,(xjs ? jsnom : (char *) 0));

	if ( xjs ) {

		/* Terminate Script Section */
		/* ------------------------ */
		html_close_script(h,jsnom);
		html_closure(h,"script");
		linefeed(h);
		
		hh = h;	h = (FILE *) 0;
		
		server_interface_record( jsnom, _WSI_SCRIPT, 0 );

		if (!( h = open_production_target( jsnom, 0 ))) {
			liberate( jsnom );
			return;
			}
		}

	/* Standard Forms Member Initialisation */
	/* ------------------------------------ */
	fprintf(h,"FocusItem=<widget name=FocusItem>;");
	linefeed(h);
	fprintf(h,"FocusItems=<widget name=FocusItems>;");
	linefeed(h);

	/* Standard Widget Class Description Function */
	/* ------------------------------------------ */
	fprintf(h,"function Widget(n,c,x,y,w,h,m,s) {"); linefeed(h);
	indent(h,1); 
		fprintf(h,"document.write(");
		fprintf(h,"%c#%c+n+",__QUOTE,__QUOTE);
		fprintf(h,"%c{ %c+c+",__QUOTE,__QUOTE);
		fprintf(h,"%c position: absolute; left: %c+x+m+",__QUOTE,__QUOTE);
		fprintf(h,"%c; top: %c+y+m+",__QUOTE,__QUOTE);
		fprintf(h,"%c; width: %c+w+m+",__QUOTE,__QUOTE);
		fprintf(h,"%c; height: %c+h+m+",__QUOTE,__QUOTE);
		fprintf(h,"%c; %c+s+",__QUOTE,__QUOTE);
		fprintf(h,"%c }\\n%c);",__QUOTE,__QUOTE);
		linefeed(h);
	indent(h,1);	
		fprintf(h,"}");					
		linefeed(h);

	fprintf(h,"function OnGetFocus() {");					linefeed(h);
		indent(h,1);	fprintf(h,"switch(FocusItem) {");		linefeed(h);
		for  ( 	iptr=fptr->first;
			iptr != (struct form_item *) 0;
			iptr = iptr->next ) { 
			if (!( iptr->Contents.focus )) 
				continue;
			else if ((iptr->Contents.style & _FRAME_TYPE) == _RADIO_FRAME)
				continue;
			else if (!( iptr->Contents.events->xo_get_focus & _EVENT_IS_FOCUS ))
				continue;
			else if (( fptr->pages  ) 
			     &&  ( iptr->Contents.page )
			     &&  (( iptr->Contents.style & _FRAME_TYPE) != _TAB_FRAME)
			     &&  (  iptr->Contents.page != HtmlPageNumber ))
				continue;
			else	{
				focusitems++;
				indent(h,2); 
				fprintf(h,"case %u :",iptr->Contents.focus);
				switch (( iptr->Contents.style & _FRAME_TYPE )) {
					case	_FORM_FRAME	:
						fprintf(h," %s<widget name=%sCell>.focus();",
							iptr->Contents.name, 
							iptr->Contents.name,
							iptr->Contents.name); 
						break;
					default			:
						fprintf(h," %s.focus();",iptr->Contents.name); 
						break;
					}
				fprintf(h," break;");
				linefeed(h);
				}
			}
		indent(h,2); fprintf(h,"default :");			 	linefeed(h);
		indent(h,2);	fprintf(h,"}");					linefeed(h);
		indent(h,1);	fprintf(h,"return(false);");			linefeed(h);
		indent(h,1);	fprintf(h,"}");					linefeed(h);

	fprintf(h,"function OnLoseFocus() {");					linefeed(h);
		indent(h,1);	fprintf(h,"return(false);");			linefeed(h);
		indent(h,1);	fprintf(h,"}");					linefeed(h);


	fprintf(h,"function EditOver(v) {");					linefeed(h);
		indent(h,1);	fprintf(h,"v.style.color='blue';");		linefeed(h);
		indent(h,1);	fprintf(h,"v.style.border='1px solid navy';");	linefeed(h);
		indent(h,1);	fprintf(h,"}");					linefeed(h);
			
	fprintf(h,"function EditOut(v) {");					linefeed(h);
		indent(h,1);	fprintf(h,"v.style.color='black';");		linefeed(h);
		indent(h,1);	fprintf(h,"v.style.border='1px solid black';");	linefeed(h);
		indent(h,1);	fprintf(h,"}");					linefeed(h);
						
	fprintf(h,"function ButtonOver(v) {");					linefeed(h);
/*		indent(h,1);	fprintf(h,"v.style.color='blue';");		linefeed(h);	*/
		indent(h,1);	fprintf(h,"v.style.border='1px inset';");	linefeed(h);
		indent(h,1);	fprintf(h,"}");					linefeed(h);
			
	fprintf(h,"function ButtonOut(v) {");					linefeed(h);
/*		indent(h,1);	fprintf(h,"v.style.color='black';");		linefeed(h);	*/
		indent(h,1);	fprintf(h,"v.style.border='1px outset';");	linefeed(h);
		indent(h,1);	fprintf(h,"}");					linefeed(h);
						
	fprintf(h,"function TabOver(v) {");					linefeed(h);
		indent(h,1);	fprintf(h,"v.style.color='blue';");		linefeed(h);
		indent(h,1);	fprintf(h,"v.style.border='1px inset';");	linefeed(h);
		indent(h,1);	fprintf(h,"}");					linefeed(h);
			
	fprintf(h,"function TabOut(v) {");					linefeed(h);
		indent(h,1);	fprintf(h,"v.style.color='black';");		linefeed(h);
		indent(h,1);	fprintf(h,"v.style.border='1px outset';");	linefeed(h);
		indent(h,1);	fprintf(h,"}");					linefeed(h);
						
	javascript_on_over( h );
	javascript_on_out( h );
	javascript_on_hint( h );

	javascript_submit_form(h);
	prefix_javascript_widget_events(h,fptr,1,"\0");

	/* generate style information from script */
	/* -------------------------------------- */
	html_form_dynamic_style(h,fptr,wptr);

	if ( xjs ) {
		close_production_target(h, jsnom );
		}
	else	{
		html_close_script(h,(char *) 0);
		}
	return;
}

public	void	html_content_type(FILE * handle)
{
	html_open_tag(handle,"meta");
		html_field(handle,"http-equiv","Content-Type");
		html_field(handle,"content","text/html; charset=iso-8859-1");
	html_close_tag(handle,"meta");			
	linefeed(handle);
	html_open_tag(handle,"meta");
		html_field(handle,"http-equiv","Content-Script-Type");
		html_field(handle,"content","text/javascript");
	html_close_tag(handle,"meta");
	linefeed(handle);
	html_open_tag(handle,"meta");
		html_field(handle,"http-equiv","Content-Style-Type");
		html_field(handle,"content","text/css");
	html_close_tag(handle,"meta");
	linefeed(handle);
	return;
}

public	void	html_generator(FILE * handle)
{
	/* META GENERATOR */
	/* -------------- */
	html_open_tag(handle,"meta");
		html_field(handle,"name","generator");
		html_field(handle,"content","Prologue Sing Html Version 2.2b");
	html_close_tag(handle,"meta");			linefeed(handle);

	/* META VERSION */
	/* ------------ */
	html_open_tag(handle,"meta");
		html_field(handle,"name","version");
		html_field(handle,"content",StringPaterne);
	html_close_tag(handle,"meta");			
	linefeed(handle);
	return;
}


public	void	html_doc_type( FILE * handle, int mode )
{
	char *	xptr;
	if ( mode ) {
		fprintf(handle,"<!DOCTYPE HTML PUBLIC %c-//W3C//DTD HTML 4.01 Framset//EN%c",__QUOTE,__QUOTE);
		fprintf(handle," %chttp://www.w3.org/TR/html4/frameset.dtd%c >",__QUOTE,__QUOTE);
		}
	else	{
		fprintf(handle,"<!DOCTYPE HTML PUBLIC %c-//W3C//DTD HTML 4.01 Transitional//EN%c",__QUOTE,__QUOTE);
		fprintf(handle," %chttp://www.w3.org/TR/html4/loose.dtd%c >",__QUOTE,__QUOTE);
		}
	linefeed(handle);
	return;
}

public	int	start_html_document(
		FILE * handle,	
		char *	title, 
		char *  logo,
		char *	sstyle,
		char *	pstyle,
		struct form_control * fptr
		)
{
	struct	form_item * wptr;

	/* <HTML> <HEAD> */
	/* ------------- */
	html_doc_type(handle,0);

	html_tag(handle,"html");
	html_tag(handle,"head");
	linefeed(handle);

	html_content_type(handle);
	html_generator(handle);

	/* Default Style and Scripts */
	/* ------------------------- */
	if ( fptr ) { html_screen_style(handle); }

	if ( not_blank( sstyle ) ) 
		html_link_style(handle, sstyle, "screen");

	if ( not_blank( pstyle ) ) 
		html_link_style(handle, pstyle, "print");

	/* <SCRIPT> */
	/* -------- */
	if ( fptr ) {	html_form_script(handle,fptr,0);	}

	/* TITLE */
	/* ----- */
	if ( not_blank( title ) ) {
		html_title(handle,title);
		}
	else	{
		html_title(handle,"no title");
		}

	/* </HEAD> <BODY> */
	/* -------------- */
	html_closure(handle,"head"); 

	if (!( fptr )) 
		html_tag(handle,"body");

	else	{
		html_open_tag(handle, "body" );
		html_field( handle,   "onload",   "OnGetFocus();" );
		html_field( handle,   "onunload", "OnLoseFocus();" );
		html_close_tag(handle,"body" );
		}

	linefeed(handle);

	if ( WSI.validate )  {
		html_tag(handle,"p");
		linefeed(handle);
		html_open_tag(handle,"a");
		html_field(handle,"href","http://validator.w3.org/check?uri=referer");
		html_close_tag(handle,"a");
		linefeed(handle);
		html_open_tag(handle,"img");
		html_field(handle,"src","valid-html401.png");
	        html_field(handle,"alt","Valid HTML 4.01 Transitional");
		html_field(handle,"height","31");
		html_field(handle,"width","88");
		html_close_tag(handle,"img");
		linefeed(handle);
		html_closure(handle,"a");
		html_closure(handle,"p");
		linefeed(handle);
		}

	if ( not_blank( title ) ) {
		html_open_tag( handle, "div" );
			html_field( handle, "align", "center" );
		html_close_tag( handle, "div" );
		linefeed(handle);

		html_open_tag( handle, "table" );
			html_field( handle, "class", "DOC" );
		html_close_tag( handle, "table" );
		linefeed(handle);

		html_tag(handle,"tr");
		html_tag(handle,"th");
		html_normalised_heading( handle, 1, title );		

		if ( not_blank( logo ) ) {
			html_tag(handle,"td");
			html_open_tag( handle, "div" );
				html_field( handle, "align", "center" );
			html_close_tag( handle, "div" );
			html_image( handle, logo, (char *) 0 );		
			html_closure(handle,"div");
			}

		html_closure(handle,"table");
		html_closure(handle,"div");
		html_tag(handle,"p");	
		linefeed(handle);
		}
	else if ( not_blank( logo ) ) {
		html_open_tag( handle, "div" );
			html_field( handle, "align", "center" );
			html_close_tag( handle, "div" );
			linefeed(handle);
		html_image( handle, logo, (char *) 0 );		
		html_closure(handle,"div");
		html_tag(handle,"p");	
		linefeed(handle);
		}

	return(1);
}

public	int	start_html_frameset(
		FILE * handle,	
		char *	title, 
		int	mode,
		char *  layout,
		char *	sstyle,
		char *	pstyle
		)
{
	/* <HTML> <HEAD> */
	/* ------------- */
	html_doc_type(handle,1);

	html_tag(handle,"html");
	html_tag(handle,"head");	linefeed(handle);
	html_content_type(handle);
	html_generator(handle);

	/* LINK STYLE */
	/* ---------- */
	html_link_style(handle, sstyle, "screen");
	html_link_style(handle, pstyle, "print");

	/* TITLE */
	/* ----- */
	if ( not_blank( title ) ) {
		html_title( handle, title );
		}

	/* </HEAD> */
	/* ------- */
	html_closure(handle,"head"); 

	/* <FRAMESET> */
	/* ---------- */
	html_frameset(handle,mode,layout);

	return(1);
}

public	void	export_html_menu( FILE * handle )
{
	if ( start_html_document( 
			handle, 
			"Sing Html Menu", 
			(char*) 0, (char *) 0, (char *) 0,(struct form_control *) 0) != 0 )
		(void) close_html_document( handle, _DEFAULT_COPYRIGHT );
	return;
}


private	void	add_row_before( struct sort_row * lptr, struct sort_item * sptr )
{
	struct	sort_row * rptr;
	if (!( rptr = allocate( sizeof( struct sort_row ) ))) {
		liberate( sptr );
		return;
		}
	SortMan.rowcount += 1;
	rptr->lock = 0;
	rptr->columns = 1;
	rptr->y  = rptr->h = 0;
	rptr->previous = rptr->next = (struct sort_row  *) 0;
	rptr->first    = rptr->last = sptr;

	if (!( rptr->previous = lptr->previous ))
		SortMan.firstrow = rptr;
	else	rptr->previous->next = rptr;
	
	if (!( rptr->next = lptr ))
		SortMan.lastrow = rptr;
	else 	rptr->next->previous = rptr;
	
	return;
}

private	struct sort_row * add_row_after( struct sort_row * lptr, struct sort_item * sptr )
{
	struct	sort_row * rptr;
	if (!( rptr = allocate( sizeof( struct sort_row ) ))) {
		liberate( sptr );
		return(rptr);
		}
	rptr->lock = 0;
	SortMan.rowcount += 1;
	rptr->columns = 1;
	rptr->y  = rptr->h = 0;
	rptr->previous = rptr->next = (struct sort_row  *) 0;
	rptr->first    = rptr->last = sptr;

	if (!( rptr->previous = lptr ))
		SortMan.firstrow = rptr;
	else	lptr->next = rptr;
	return( rptr );
}

private	void	add_to_row( struct sort_row * rptr, struct sort_item * sptr )
{
	struct	form_item *iptr;
	struct	form_item *wptr;
	struct	sort_item *cptr;
	iptr = sptr->widget;
	for ( cptr=rptr->first; cptr != (struct sort_item *) 0; cptr = cptr->next ) {
		if (!( wptr = cptr->widget ))
			continue;
		else if (( iptr->Contents.style & _FRAME_TYPE ) == _TAB_FRAME ) {
			if (( wptr->Contents.style & _FRAME_TYPE ) == _TAB_FRAME ) {
				if ( (iptr->Contents.x+iptr->Contents.adjust) < (wptr->Contents.x+wptr->Contents.adjust)) {
					if (!( sptr->previous = cptr->previous ))
						rptr->first = sptr;
					else	sptr->previous->next = sptr;
					sptr->next = cptr;
					cptr->previous = sptr;
					return;
					}
				else	continue;
				}
			else	{
				if ( (iptr->Contents.x+iptr->Contents.adjust) < wptr->Contents.x) {
					if (!( sptr->previous = cptr->previous ))
						rptr->first = sptr;
					else	sptr->previous->next = sptr;
					sptr->next = cptr;
					cptr->previous = sptr;
					return;
					}
				else	continue;

				}
			}
		else if (( wptr->Contents.style & _FRAME_TYPE ) == _TAB_FRAME ) {
			if ( iptr->Contents.x < (wptr->Contents.x+wptr->Contents.adjust)) {
				if (!( sptr->previous = cptr->previous ))
					rptr->first = sptr;
				else	sptr->previous->next = sptr;
				sptr->next = cptr;
				cptr->previous = sptr;
				return;
				}
			else	continue;
			}
		else if ( iptr->Contents.x < wptr->Contents.x ) {
			if (!( sptr->previous = cptr->previous ))
				rptr->first = sptr;
			else	sptr->previous->next = sptr;
			sptr->next = cptr;
			cptr->previous = sptr;
			return;
			}
		}
	if (!( sptr->previous = rptr->last ))
		rptr->last = sptr;
	else	rptr->last->next = sptr;
	rptr->last = sptr;
	rptr->columns++;
	if ( rptr->columns > SortMan.maxcolumns )
		SortMan.maxcolumns = rptr->columns;
	return;
}
		

private	void	calculate_row_size( struct sort_row * rptr )
{
	struct	sort_item *cptr;
	struct	form_item *wptr;
	struct window_control Widget;
	rptr->y = -1; rptr->h = 0;
	for ( 	cptr=rptr->first; 
		cptr != (struct sort_item *) 0; 
		cptr = cptr->next ) {
		if (!( wptr = cptr->widget ))
			continue;
		else	html_widget_size(wptr,&Widget,0);

		/* -------------------------------- */
		/* Determine the row start position */
		/* -------------------------------- */
		if ( rptr->y == -1 ) {
			rptr->y = Widget.y;
			rptr->h = Widget.h;
			}
		else if ( rptr->y > Widget.y ) {
			rptr->y = Widget.y;
			if ((rptr->y + rptr->h) < ( Widget.y + Widget.h ))
				rptr->h = (( Widget.y + Widget.h ) - rptr->y);
			}
		}
	return;
}

private	void	add_sort_cell( 
		struct sort_cell * lptr,
		struct sort_cell * sptr,
		struct sort_cell * cptr
		)
{
	if (( sptr->next = cptr ) != (struct sort_cell *) 0)
		cptr->previous = sptr;
	if (( sptr->previous = lptr ) != (struct sort_cell *) 0)
		lptr->next = sptr;
	else	SortList   = sptr;
	return;
}

private	void	show_column_info()
{
	int	i;
	printf("Columns:");
	for (i=0; i < cellcount; i++ )
		printf(" (x=%u,w=%u)",cellposition[i],cellwidth[i]);
	printf("\r\n");
	return;
}

private	void	show_row_info()
{
	int	i;
	printf("Rows:");
	for (i=0; i < rowcount; i++ )
		printf(" (y=%u,h=%u)",rowposition[i],rowheight[i]);
	printf("\r\n");
	return;
}

private	void	append_table_cell()
{
	cellcount++;
	if ( GenerateDebug ) { printf("append_table_cell(%u)\r\n",cellcount); }
	return;
}

private	void	insert_table_cell(int i)
{
	int	j;
	if ( GenerateDebug ) { printf("insert_table_cell(%u)\r\n",i); }
	for ( j=cellcount; j > i; j-- ) {
		cellposition[j] = cellposition[(j-1)];
		cellwidth[j] = cellwidth[(j-1)];
		}
	cellcount++;
	return;
}

private	void	append_table_row()
{
	rowcount++;
	if ( GenerateDebug ) { printf("append_table_row(%u)\r\n",rowcount); }
	return;
}

private	void	insert_table_row(int i)
{
	int	j;
	if ( GenerateDebug ) { printf("insert_table_row(%u)\r\n",i); }
	for ( j=rowcount; j > i; j-- ) {
		rowposition[j] = rowposition[(j-1)];
		rowheight[j] = rowheight[(j-1)];
		}
	rowcount++;
	return;
}

private	void	check_column_limits(struct form_item * wptr )
{
	int	j;
	int	x;
	int	w;
	int	fh;
	int	fw;
	/* detect window widget */
	/* -------------------- */
	if (!( wptr )) {
		x = 0; 
		w = 0;
		}
	else	{
		fw = guifontsize(wptr->Contents.font);
		fh = (fw >> 8); fw &= 0x00FF;	
		switch ((wptr->Contents.style & _FRAME_TYPE )) {
			case	_TAB_FRAME	:
				x = (wptr->Contents.x + wptr->Contents.adjust);
				w = ((wptr->Contents.size+2) * fw);
				break;
			default			:
				x = wptr->Contents.x;
				w = wptr->Contents.w;

			}
		}

	/* Add initial cell if not already on left margin */
	/* ---------------------------------------------- */
	if ( cellposition[0] > x )  {
		insert_table_cell(0);
		cellposition[0] = 0;
		cellwidth[0] = cellposition[1];
		if ( GenerateDebug ) { show_column_info(); }
		}

	/* Add padding cell to right */
	/* ------------------------- */
	if (( cellposition[(cellcount-1)] + cellwidth[(cellcount-1)] ) < ( x + w )) {
		cellposition[cellcount] = (cellposition[(cellcount-1)] + cellwidth[(cellcount-1)]);
		cellwidth[cellcount] = ((x+w)-(cellposition[(cellcount-1)] + cellwidth[(cellcount-1)]));
		append_table_cell();
		if ( GenerateDebug ) { show_column_info(); }
		}
	return;
}	

private	void	check_row_limits(struct form_item * wptr )
{
	int	j;
	int	y;
	int	h;
	int	k;
	int	fh;
	int	fw;
	if (!( wptr )) {
		y = 0; 
		h = 0;
		}
	else	{
		fw = guifontsize(wptr->Contents.font);
		fh = (fw >> 8); fw &= 0x00FF;	
		switch ((wptr->Contents.style & _FRAME_TYPE )) {
			case	_TAB_FRAME	:
				h = (fh * 2);
				y = wptr->Contents.y;
				break;
			default			:
				y = wptr->Contents.y;
				h = wptr->Contents.h;
			}
		}
#ifdef	_check_top_row
	if ( rowposition[0] > y )  {
		/* insert initial cell */
		for ( j=rowcount; j > 0; j-- ) {
			rowposition[j] = rowposition[(j-1)];
			rowheight[j] = rowheight[(j-1)];
			}
		rowcount++;
		rowposition[0] = 0;
		rowheight[0] = rowposition[1];
		}
#endif
	if (( rowposition[(rowcount-1)] + rowheight[(rowcount-1)] ) < ( y + h )) {
		rowposition[rowcount] = (rowposition[(rowcount-1)] + rowheight[(rowcount-1)]);
		rowheight[rowcount] = ((y+h)-(rowposition[(rowcount-1)] + rowheight[(rowcount-1)]));
		rowcount++;
		}
	return;
}	

private	int	at_cell_position(int i, struct window_control * Sample )
{
	int	extra;

	if ( Sample->x != cellposition[i] ) {
		/* ---------------------- */
		/* Not identical Position */
		/* ---------------------- */
		return(2);	
		}
	else if ( Sample->w == cellwidth[i] ) {
		/* -------------------- */
		/* Identical Dimensions */
		/* -------------------- */
		debug_message("at_cell_position : identical dimensions\r\n");
		return(0);
		}
	else if ( Sample->w > cellwidth[i] ) {
		/* ------------------------------ */
		/* handle cell overspill to right */
		/* ------------------------------ */
		Sample->x += cellwidth[i];
		Sample->w -= cellwidth[i];
		debug_message("at_cell_position : overspill right\r\n");
		return(1);
		}
	else 	{
		/* ----------------------------------- */
		/* Sample->w is less than cellwidth[i] */
		/* ----------------------------------- */
		extra = cellwidth[i] - Sample->w;
		cellwidth[i] = Sample->w;
		Sample->x += Sample->w;
		Sample->w  = extra;
		i++;
		if ( i < cellcount )
			insert_table_cell(i);
		else	append_table_cell();
		cellposition[i] = Sample->x;
		cellwidth[i]    = Sample->w;
		debug_message("at_cell_position : less than cell width\r\n");
		return(0);
		}
}

private	int	before_cell_position(int i, struct window_control * Sample )
{
	int	extra;

	/* --------------------------------------*/
	/* Detect Sample Inserted before current */
	/* ------------------------------------- */
	if ( Sample->x >= cellposition[i] )
		return(2);

	/* ----------------------------- */
	/* check for no cell to the left */
	/* ----------------------------- */
	else 	{
		insert_table_cell(i);
		cellposition[i] = Sample->x;

		if (!( i )) {


			if ((Sample->x+Sample->w) == cellposition[i+1] ) {
				/* ---------------------- */
				/* no padding or clipping */
				/* ---------------------- */
				cellwidth[i] == Sample->w;
				debug_message("before_cell_position : !i no padding or clipping\r\n");
				return(0);
				}

			if ((Sample->x+Sample->w) > cellposition[i+1] ) {
				/* ------------------------ */
				/* Overspill into next cell */
				/* ------------------------ */
				cellwidth[i] = (cellposition[i+1]-Sample->x);
				Sample->x += cellwidth[i];
				Sample->w -= cellwidth[i];
				debug_message("before_cell_position : !i overspill into next cell\r\n");
				return(1);
				}
			else	{
				/* ---------------------------------- */
				/* Split into left and right portions */
				/* ---------------------------------- */
				cellwidth[i] = Sample->w;
				Sample->x += Sample->w;
				Sample->w = (cellposition[i+1]-Sample->x);
				insert_table_cell(i+1);
				cellposition[i+1] = Sample->x;
				cellwidth[i+1] = Sample->w;
				cellposition[i+1] = Sample->x;
				debug_message("before_cell_position : !i split left and right\r\n");
				return(0);
				}
			}
		else	{
			/* --------------------------------------------------- */
			/* Cell exists to the left : this one starts inside it */
			/* --------------------------------------------------- */
			extra = cellwidth[i-1];
			cellwidth[i-1] = (Sample->x - cellposition[i-1]);
			extra -= cellwidth[i-1];
			if ((Sample->x+Sample->w) == cellposition[i+1]) {
				cellwidth[i] = Sample->w;
				debug_message("before_cell_position : i exact fit\r\n");
				return(0);
				}
			else if ((Sample->x+Sample->w) > cellposition[i+1]) {
				cellwidth[i] = (cellposition[i+1]-Sample->x);
				Sample->w -= cellwidth[i];
				Sample->x += cellwidth[i];
				debug_message("before_cell_position : i overspill next\r\n");
				return(1);
				}
			else	{
				cellwidth[i] = Sample->w;
				Sample->x += Sample->w;
				extra    -= Sample->w;
				insert_table_cell(i+1);
				cellposition[i+1] = Sample->x;
				cellwidth   [i+1] = extra;
				debug_message("before_cell_position : i split previous\r\n");
				return(0);
				}
			}
		}
}

private	int	after_cell_position(int i, struct window_control * Sample )
{
	int	extra;

	if ( i < cellcount )
		return(1);

	else	{
		append_table_cell();
		cellposition[i] = Sample->x;

		if ((cellposition[i-1]+cellwidth[i-1]) == Sample->x) {
			/* ------------------------------ */
			/* append to exact end of current */
			/* ------------------------------ */
			cellwidth[i] = Sample->w;
			debug_message("after_cell_position : append exact end\r\n");
			return(0);
			}

		else if ((cellposition[i-1]+cellwidth[i-1]) < Sample->x) {
			/* ------------------------------------------- */
			/* append to beyond end and insert filler cell */
			/* ------------------------------------------- */
			cellwidth[i] = Sample->w;
			Sample->w = (Sample->x-(cellposition[i-1]+cellwidth[i-1]));
			Sample->x = (cellposition[i-1]+cellwidth[i-1]);
			insert_table_cell(i);
			cellposition[i] = Sample->x;
			cellwidth[i] = Sample->w;
			debug_message("after_cell_position : append beyond with filler\r\n");
			return(0);
			}
		else if ((cellposition[i-1] + cellwidth[i-1]) == (Sample->x+Sample->w)) {
			/* --------------- */
			/* Split last cell */
			/* --------------- */
			cellwidth[i-1] = (Sample->x - cellposition[i-1]);
			cellwidth[i]   = Sample->w;
			debug_message("after_cell_position : append split last\r\n");
			return(0);
			}
		else if ((cellposition[i-1] + cellwidth[i-1]) > (Sample->x+Sample->w)) {
			/* --------------------------------------- */
			/* split last cell and insert the new cell */
			/* --------------------------------------- */
			cellwidth[i]   = Sample->w;
			extra = cellwidth[i-1];
			cellwidth[i-1] = (Sample->x - cellposition[i-1]);
			extra -= cellwidth[i-1];
			extra -= Sample->w;
			Sample->x += Sample->w;
			append_table_cell();
			cellposition[i+1] = Sample->x;
			cellwidth[i+1] = Sample->w;
			debug_message("after_cell_position : append split last and insert\r\n");
			return(0);
			}
		else	{
			extra = cellwidth[i-1];
			cellwidth[i-1] = (Sample->x - cellposition[i-1]);
			extra -= cellwidth[i-1];
			cellwidth[i] = extra;
			Sample->w -= extra;
			Sample->x += extra;
			append_table_cell();
			cellposition[i+1] = Sample->x;
			cellwidth[i+1] = Sample->w;
			debug_message("after_cell_position : split last extend\r\n");
			return(0);
			}

		}
}

private	void	adjust_column_info(struct form_item * iptr )
{
	int	i=0;

	struct window_control Sample;

	if (!( iptr ))
		return;
	else	{
		/* ---------------------------------------------- */
		/* determine legal widget and calculate cell size */
		/* ---------------------------------------------- */
		switch ((iptr->Contents.style & _FRAME_TYPE )) {
			case	_TAB_FRAME	:
			case	_SELECT_FRAME	:
			case	_EDIT_FRAME	:
			case	_CHECK_FRAME	:
			case	_RADIO_FRAME	:
			case	_SWITCH_FRAME	:
			case	_SCROLL_FRAME	:
			case	_BUTTON_FRAME	:
			case	_FORM_FRAME	:
			case	_IMAGE_FRAME	:
			case	_TEXT_FRAME	:
				html_widget_size(iptr,&Sample,0);
				break;

			case	_DATA_FRAME	:
			case	_WINDOW_FRAME	:
			default			:
				return;
			}
		}

	if ( GenerateDebug ) {
		printf("CellCount : %u : Widget : name=%s at x=%u w=%u ",cellcount,iptr->Contents.name,Sample.x,Sample.w);
		debug_message("\r\n");
		}

	/* -------------------------- */	
	/* Detect Simple initial case */
	/* -------------------------- */	
	if (!( cellcount )) {
		append_table_cell();
		cellposition[0] = Sample.x;
		cellwidth[0] 	= Sample.w;
		if ( GenerateDebug ) { show_column_info(); }
		return;
		}

	/* ----------------------------------------- */
	/* Scan existing columns to integrate sample */
	/* ----------------------------------------- */

	while (Sample.w != 0) {

		switch ( at_cell_position(i, &Sample) ) {
			case	0 :	if ( GenerateDebug ) { show_column_info(); }
					return;
			case	1 :	continue;
			default	  :

				switch ( before_cell_position(i, &Sample) ) {
					case	0 :	if ( GenerateDebug ) { show_column_info(); }
							return;
					case	1 :	continue;
					default	  :	

						i++;

						switch ( after_cell_position(i, &Sample ) ) {
							case	0 :	if ( GenerateDebug ) { show_column_info(); }
									return;
							default	  :	continue;
							}
					}
			}
		}

	if ( GenerateDebug ) { show_column_info(); }
	return;
}

private	int	at_row_position(int i, struct window_control * Sample )
{
	int	extra;

	if ( Sample->y != rowposition[i] ) {
		/* ---------------------- */
		/* Not identical Position */
		/* ---------------------- */
		return(2);	
		}
	else if ( Sample->h == rowheight[i] ) {
		/* -------------------- */
		/* Identical Dimensions */
		/* -------------------- */
		debug_message("at_row_position : identical dimensions\r\n");
		return(0);
		}
	else if ( Sample->h > rowheight[i] ) {
		/* ------------------------------ */
		/* handle row overspill to right */
		/* ------------------------------ */
		Sample->y += rowheight[i];
		Sample->h -= rowheight[i];
		debug_message("at_row_position : overspill right\r\n");
		return(1);
		}
	else 	{
		/* ----------------------------------- */
		/* Sample->h is less than rowheight[i] */
		/* ----------------------------------- */
		extra = rowheight[i] - Sample->h;
		rowheight[i] = Sample->h;
		Sample->y += Sample->h;
		Sample->h  = extra;
		i++;
		if ( i < rowcount )
			insert_table_row(i);
		else	append_table_row();
		rowposition[i] = Sample->y;
		rowheight[i]    = Sample->h;
		debug_message("at_row_position : less than row width\r\n");
		return(0);
		}
}

private	int	before_row_position(int i, struct window_control * Sample )
{
	int	extra;

	/* --------------------------------------*/
	/* Detect Sample Inserted before current */
	/* ------------------------------------- */
	if ( Sample->y >= rowposition[i] )
		return(2);

	/* ----------------------------- */
	/* check for no row to the left */
	/* ----------------------------- */
	else 	{
		insert_table_row(i);
		rowposition[i] = Sample->y;

		if (!( i )) {


			if ((Sample->y+Sample->h) == rowposition[i+1] ) {
				/* ---------------------- */
				/* no padding or clipping */
				/* ---------------------- */
				rowheight[i] == Sample->h;
				debug_message("before_row_position : !i no padding or clipping\r\n");
				return(0);
				}

			if ((Sample->y+Sample->h) > rowposition[i+1] ) {
				/* ------------------------ */
				/* Overspill into next row */
				/* ------------------------ */
				rowheight[i] = (rowposition[i+1]-Sample->y);
				Sample->y += rowheight[i];
				Sample->h -= rowheight[i];
				debug_message("before_row_position : !i overspill into next row\r\n");
				return(1);
				}
			else	{
				/* ---------------------------------- */
				/* Split into left and right portions */
				/* ---------------------------------- */
				rowheight[i] = Sample->h;
				Sample->y += Sample->h;
				Sample->h = (rowposition[i+1]-Sample->y);
				insert_table_row(i+1);
				rowposition[i+1] = Sample->y;
				rowheight[i+1] = Sample->h;
				rowposition[i+1] = Sample->y;
				debug_message("before_row_position : !i split left and right\r\n");
				return(0);
				}
			}
		else	{
			/* --------------------------------------------------- */
			/* Cell exists to the left : this one starts inside it */
			/* --------------------------------------------------- */
			extra = rowheight[i-1];
			rowheight[i-1] = (Sample->y - rowposition[i-1]);
			extra -= rowheight[i-1];
			if ((Sample->y+Sample->h) == rowposition[i+1]) {
				rowheight[i] = Sample->h;
				debug_message("before_row_position : i exact fit\r\n");
				return(0);
				}
			else if ((Sample->y+Sample->h) > rowposition[i+1]) {
				rowheight[i] = (rowposition[i+1]-Sample->y);
				Sample->h -= rowheight[i];
				Sample->y += rowheight[i];
				debug_message("before_row_position : i overspill next\r\n");
				return(1);
				}
			else	{
				rowheight[i] = Sample->h;
				Sample->y += Sample->h;
				extra    -= Sample->h;
				insert_table_row(i+1);
				rowposition[i+1] = Sample->y;
				rowheight   [i+1] = extra;
				debug_message("before_row_position : i split previous\r\n");
				return(0);
				}
			}
		}
}

private	int	after_row_position(int i, struct window_control * Sample )
{
	int	extra;

	if ( i < rowcount )
		return(1);

	else	{
		append_table_row();
		rowposition[i] = Sample->y;

		if ((rowposition[i-1]+rowheight[i-1]) == Sample->y) {
			/* ------------------------------ */
			/* append to exact end of current */
			/* ------------------------------ */
			rowheight[i] = Sample->h;
			debug_message("after_row_position : append exact end\r\n");
			return(0);
			}

		else if ((rowposition[i-1]+rowheight[i-1]) < Sample->y) {
			/* ------------------------------------------- */
			/* append to beyond end and insert filler row */
			/* ------------------------------------------- */
			rowheight[i] = Sample->h;
			Sample->h = (Sample->y-(rowposition[i-1]+rowheight[i-1]));
			Sample->y = (rowposition[i-1]+rowheight[i-1]);
			insert_table_row(i);
			rowposition[i] = Sample->y;
			rowheight[i] = Sample->h;
			debug_message("after_row_position : append beyond with filler\r\n");
			return(0);
			}
		else if ((rowposition[i-1] + rowheight[i-1]) == (Sample->y+Sample->h)) {
			/* --------------- */
			/* Split last row */
			/* --------------- */
			rowheight[i-1] = (Sample->y - rowposition[i-1]);
			rowheight[i]   = Sample->h;
			debug_message("after_row_position : append split last\r\n");
			return(0);
			}
		else if ((rowposition[i-1] + rowheight[i-1]) > (Sample->y+Sample->h)) {
			/* --------------------------------------- */
			/* split last row and insert the new row */
			/* --------------------------------------- */
			rowheight[i]   = Sample->h;
			extra = rowheight[i-1];
			rowheight[i-1] = (Sample->y - rowposition[i-1]);
			extra -= rowheight[i-1];
			extra -= Sample->h;
			Sample->y += Sample->h;
			append_table_row();
			rowposition[i+1] = Sample->y;
			rowheight[i+1] = Sample->h;
			debug_message("after_row_position : append split last and insert\r\n");
			return(0);
			}
		else	{
			extra = rowheight[i-1];
			rowheight[i-1] = (Sample->y - rowposition[i-1]);
			extra -= rowheight[i-1];
			rowheight[i] = extra;
			Sample->h -= extra;
			Sample->y += extra;
			append_table_row();
			rowposition[i+1] = Sample->y;
			rowheight[i+1] = Sample->h;
			debug_message("after_row_position : split last extend\r\n");
			return(0);
			}

		}
}

private	void	adjust_row_info(struct form_item * iptr )
{
	int	i=0;

	struct window_control Sample;

	if (!( iptr ))
		return;
	else	{
		/* ---------------------------------------------- */
		/* determine legal widget and calculate row size */
		/* ---------------------------------------------- */
		switch ((iptr->Contents.style & _FRAME_TYPE )) {
			case	_TAB_FRAME	:
			case	_SELECT_FRAME	:
			case	_EDIT_FRAME	:
			case	_CHECK_FRAME	:
			case	_RADIO_FRAME	:
			case	_SWITCH_FRAME	:
			case	_SCROLL_FRAME	:
			case	_BUTTON_FRAME	:
			case	_FORM_FRAME	:
			case	_IMAGE_FRAME	:
			case	_TEXT_FRAME	:
				html_widget_size(iptr,&Sample,0);
				break;

			case	_DATA_FRAME	:
			case	_WINDOW_FRAME	:
			default			:
				return;
			}
		}

	if ( GenerateDebug ) {
		printf("CellCount : %u : Widget : name=%s at x=%u w=%u ",rowcount,iptr->Contents.name,Sample.x,Sample.w);
		debug_message("\r\n");
		}

	/* -------------------------- */	
	/* Detect Simple initial case */
	/* -------------------------- */	
	if (!( rowcount )) {
		append_table_row();
		rowposition[0] = Sample.y;
		rowheight[0] 	= Sample.h;
		if ( GenerateDebug ) { show_row_info(); }
		return;
		}

	/* ----------------------------------------- */
	/* Scan existing columns to integrate sample */
	/* ----------------------------------------- */

	while (Sample.w != 0) {

		switch ( at_row_position(i, &Sample) ) {
			case	0 :	if ( GenerateDebug ) { show_row_info(); }
					return;
			case	1 :	continue;
			default	  :

				switch ( before_row_position(i, &Sample) ) {
					case	0 :	if ( GenerateDebug ) { show_row_info(); }
							return;
					case	1 :	continue;
					default	  :	

						i++;

						switch ( after_row_position(i, &Sample ) ) {
							case	0 :	if ( GenerateDebug ) { show_row_info(); }
									return;
							default	  :	continue;
							}
					}
			}
		}

	if ( GenerateDebug ) { show_row_info(); }
	return;
}

private	void	old_adjust_row_info(struct form_item * iptr )
{
	int	i;
	int	j;
	struct window_control Window;

	if (!( iptr ))
		return;

	html_widget_size(iptr,&Window,0);

	switch ((iptr->Contents.style & _FRAME_TYPE )) {
		case	_SELECT_FRAME	:
		case	_TAB_FRAME	:
		case	_EDIT_FRAME	:
		case	_CHECK_FRAME	:
		case	_RADIO_FRAME	:
		case	_SWITCH_FRAME	:
		case	_SCROLL_FRAME	:
		case	_BUTTON_FRAME	:
		case	_FORM_FRAME	:
		case	_IMAGE_FRAME	:
		case	_TEXT_FRAME	:
			break;

		case	_DATA_FRAME	:
		case	_WINDOW_FRAME	:
		default			:
			return;
		}

	if (!( rowcount )) {
		rowposition[0] = Window.y;
		rowheight[0] = Window.h;
		rowcount=1;
		if ( GenerateDebug ) { show_row_info(); }
		return;
		}
	for (i=0; i < rowcount; i++ ) {
		if ( Window.y < rowposition[i] ) {
			for ( j=rowcount; j > i; j-- ) {
				rowposition[j] = rowposition[(j-1)];
				rowheight[j] = rowheight[(j-1)];
				}
			rowcount+=1;
			rowposition[i] = Window.y;
			if ((Window.y+Window.h) > rowposition[i+1])
				rowheight[i] = (rowposition[i+1] - Window.h);
			else	rowheight[i] = Window.h;
			if ( GenerateDebug ) { show_row_info(); }
			return;
			}
		else if ( Window.y == rowposition[i] )
			return;
		}
	j = (rowcount-1);
	if ( Window.y < (rowposition[j]+rowheight[j]))
		rowheight[j] = (Window.y - rowposition[j]);

	rowcount++; j++;
	rowposition[j] = Window.y;
	rowheight[j] = Window.h;
	if ( GenerateDebug ) { show_row_info(); }
	return;
}

public	void	add_sort_widget( struct form_item * iptr)
{
	struct	sort_cell *sptr;
	struct	sort_cell *cptr;
	struct	sort_cell *pptr;
	struct	form_item * wptr;
	struct window_control Widget;
	struct window_control Other;
	if (!( iptr ))
		return;
	else if (!( sptr = allocate( sizeof( struct sort_cell ) ) ))
		return;
	else	{
		sptr->previous = sptr->next =(struct sort_item *) 0;
		sptr->widget   = iptr;
		html_widget_size(iptr,&Widget,0);
		if (!( SortList )) {
			add_sort_cell( SortList, sptr, SortList );
			return;
			}
		for ( 	cptr = SortList, pptr = (struct sort_cell *) 0;
			cptr != ( struct sort_cell *) 0;
			cptr = cptr->next ) {
			html_widget_size(cptr->widget,&Other,0);
			if ( Widget.y < Other.y ) {
				add_sort_cell(cptr->previous, sptr, cptr );
				return;
				}
			else if ( Widget.y == Other.y ) {
				if ( Widget.x < Other.x ) {
					add_sort_cell(cptr->previous, sptr, cptr );
					return;
					}
				}
			pptr = cptr;
			}
		add_sort_cell(pptr,sptr,pptr->next);
		return;
		}
}
	
private	void	adjust_for_rowspan(struct sort_row * rptr, int y, int h )
{
	struct	sort_item *cptr;
	struct	form_item *wptr;
	int	wh;
	for ( cptr=rptr->first; cptr != (struct sort_item *) 0; cptr = cptr->next ) {
		if (!( wptr = cptr->widget ))
			continue;
		switch ((wptr->Contents.style & _FRAME_TYPE )) {
			case	_SELECT_FRAME	:
				wh = (((guifontsize(wptr->Contents.font) >> 8) & 0x00FF)+2);
				break;

			case	_TEXT_FRAME	:
			case	_EDIT_FRAME	:
			case	_CHECK_FRAME	:
			case	_RADIO_FRAME	:
			case	_SWITCH_FRAME	:
			case	_SCROLL_FRAME	:
			case	_BUTTON_FRAME	:
			case	_FORM_FRAME	:
				wh = wptr->Contents.h;
				break;
			default			:
				continue;
			}
		if (( y >= wptr->Contents.y)
		&& ( (y+h) <= (wptr->Contents.y+wh)))
			cptr->rowspan++;
		}
	return;
}

private	int	check_for_rowspan(struct sort_row * rptr, int y, int h )
{
	struct	sort_item *cptr;
	struct	form_item *wptr;
	int	wh;
	for ( cptr=rptr->first; cptr != (struct sort_item *) 0; cptr = cptr->next ) {
		if (!( wptr = cptr->widget ))
			continue;
		switch ((wptr->Contents.style & _FRAME_TYPE )) {
			case	_SELECT_FRAME	:
				wh = (((guifontsize(wptr->Contents.font) >> 8) & 0x00FF)+2);
				break;

			case	_TEXT_FRAME	:
			case	_EDIT_FRAME	:
			case	_CHECK_FRAME	:
			case	_RADIO_FRAME	:
			case	_SWITCH_FRAME	:
			case	_SCROLL_FRAME	:
			case	_BUTTON_FRAME	:
			case	_FORM_FRAME	:
				wh = wptr->Contents.h;
				break;
			default			:
				continue;
			}
		if ( y > (wptr->Contents.y+wh)) {
			adjust_for_rowspan(rptr,y,h);
			return(1);
			}

		}
	return(0);
}

public	void	add_sort_item( struct form_item * iptr)
{
	struct	sort_item *sptr;
	struct	sort_row  *rptr;
	struct window_control Widget;

	if (!( iptr ))
		return;
	else	html_widget_size(iptr,&Widget,0);

	switch ((iptr->Contents.style & _FRAME_TYPE )) {
		case	_SELECT_FRAME	:
		case	_TAB_FRAME	:
			SortMan.formitems += 1;
			break;

		case	_EDIT_FRAME	:
		case	_CHECK_FRAME	:
		case	_RADIO_FRAME	:
		case	_SWITCH_FRAME	:
		case	_BUTTON_FRAME	:
		case	_FORM_FRAME	:
		case	_SCROLL_FRAME	:
			SortMan.formitems += 1;

		case	_IMAGE_FRAME	:
		case	_TEXT_FRAME	:
			break;

		case	_WINDOW_FRAME	:
			SortMan.window = iptr;
			return;

		default			:
			return;
		}

	if (!( sptr = allocate( sizeof( struct sort_item ) ) ))
		return;
	else	{
		sptr->colspan  = sptr->rowspan = 1;
		sptr->previous = sptr->next =(struct sort_item *) 0;
		sptr->widget   = iptr;
		for ( 	rptr = SortMan.firstrow;
			rptr != ( struct sort_row *) 0;
			rptr = rptr->next ) {

			if ( Widget.y == rptr->y ) {
				if (!( check_for_rowspan( rptr, Widget.x,Widget.h ))) {
					add_to_row(rptr, sptr );
					calculate_row_size( rptr );
					}
				else	add_to_row( rptr, sptr );
				return;
				}
			else if ( Widget.y > rptr->y ) {
				if ( Widget.y < ( rptr->y + rptr->h)) {
					if (!( check_for_rowspan( rptr, Widget.x,Widget.h ))) {
						add_to_row( rptr, sptr );
						calculate_row_size( rptr );
						}
					else 	{
						SortMan.lastrow = add_row_after( SortMan.lastrow,sptr);
						calculate_row_size( SortMan.lastrow );
						}
					return;
					}
				}
			else if ( Widget.y < rptr->y ) {
				if (( Widget.y + Widget.h ) < rptr->y ) {
					add_row_before(rptr,sptr);
					calculate_row_size( rptr->previous );
					return;
					}
				else	{
					add_to_row( rptr, sptr );
					calculate_row_size( rptr );
					return;
					}
				}
			}
		SortMan.lastrow = add_row_after(SortMan.lastrow,sptr);
		calculate_row_size( SortMan.lastrow );
		return;
		}
}
		
private	void	drop_sort_items()
{
	struct sort_row  * rptr;
	struct sort_item * sptr;
	struct sort_cell * cptr;

	cellcount=0;
	rowcount=0;

	while ((rptr = SortMan.firstrow) != (struct sort_row *) 0) {
		SortMan.firstrow = rptr->next;
		while ((sptr = rptr->first) != (struct sort_item *) 0) {
			rptr->first = sptr->next;
			liberate( sptr );
			}
		liberate( rptr );
		}

	SortMan.formitems = SortMan.maxcolumns = SortMan.rowcount = 0;
	SortMan.firstrow = SortMan.lastrow = (struct sort_row *) 0;
	SortMan.window  = (struct form_item *) 0;

	while ((cptr = SortList) != (struct sort_cell*) 0) {
		SortList = cptr->next;
		liberate( cptr );
		}

	SortList = (struct sort_cell *) 0;
	return;
}		

public	void	html_form(FILE * h, char * nptr, char * aptr, char * eptr, char * mptr )
{
	if ( h ) {
		html_open_tag(h,"form");
		if ( nptr )
			html_field(h,"name",nptr);
		if ( aptr )
			html_field(h,"action",aptr);
		if ( eptr )
			html_field(h,"enctype",eptr);
		if ( mptr )
			html_field(h,"method",mptr);
		html_close_tag(h,"form");
		linefeed(h);
		}
	return;
}

public	void	html_input_file( FILE * h, char * nptr, char * vptr )
{
	html_open_tag(h,"input");
	html_field(h,"type","file");
	html_field(h,"name",nptr);
	fprintf(h," value=%c%s%c",__QUOTE,vptr,__QUOTE);
	html_close_tag(h,"input");
	return;
}

public	void	html_input_submit( FILE * h, char * nptr, char * vptr )
{
	html_open_tag(h,"input");
	html_field(h,"type","submit");
	html_field(h,"name",nptr);
	fprintf(h," value=%c%s%c",__QUOTE,vptr,__QUOTE);
	html_close_tag(h,"input");
	return;
}

private	int	check_for_urlencoding(FILE * h,struct form_control * fptr)
{
	if ( SortMan.formitems != 0 ) {
		html_tag(h,"p");
		html_open_tag(h,"input");
		html_field(h,"type","hidden");
		html_field(h,"name","Method");
		fprintf(h," value=%c %c",__QUOTE,__QUOTE);
		html_close_tag(h,"input");
		linefeed(h);
		}
	return( SortMan.formitems );
}

private	int	debug_sort_list(FILE * h)
{
	struct	sort_cell * cptr;
	int	i;
	
	fprintf(h,"<p><table border=1 id=windowframe><tr><td width=%c30%c%c>",__QUOTE,__PERCENT,__QUOTE);
	fprintf(h,"widget information<p><table id=windowinner>");
	linefeed(h);
	fprintf(h,"<tr><th>widget<th>x<th>y<th>w<th>h");
	linefeed(h);
	for (	cptr=SortList;
		cptr != (struct sort_cell *) 0;
		cptr = cptr->next ) {
		fprintf(h,"<tr><th>%s<td>%u<td>%u<td>%u<td>%u",
			cptr->widget->Contents.name,
			cptr->widget->Contents.x,
			cptr->widget->Contents.y,
			cptr->widget->Contents.w,
			cptr->widget->Contents.h);
		linefeed(h);
		}
	fprintf(h,"</table>");
	linefeed(h);

	fprintf(h,"<td width=%c30%c%c>cell information<p><table id=windowinner>",__QUOTE,__PERCENT,__QUOTE);
	linefeed(h);
	fprintf(h,"<tr><th>cell<th>position<th>width");
	linefeed(h);
	for (i=0; i < cellcount; i++ ) {
		fprintf(h,"<tr><th>%u<td>%u<td>%u",i,cellposition[i],cellwidth[i]);
		linefeed(h);
		}
	fprintf(h,"</table>");
	linefeed(h);

	fprintf(h,"<td width=%c30%c%c>row information<p><table id=windowinner>",__QUOTE,__PERCENT,__QUOTE);
	linefeed(h);
	fprintf(h,"<tr><th>row<th>position<th>width");
	linefeed(h);
	for (i=0; i < rowcount; i++ ) {
		fprintf(h,"<tr><th>%u<td>%u<td>%u",i,rowposition[i],rowheight[i]);
		linefeed(h);
		}
	fprintf(h,"</table></table>");
	linefeed(h);
	return;
}

private	int	generate_sort_window(FILE * h, struct form_item * wptr )
{
	int	i;
	generate_html( h, wptr );
	if ( GenerateDebug ) {
		fprintf(h,"<tr>");
		linefeed(h);
		if ( cellposition[0] > wptr->Contents.x ) {
			fprintf(h,"<td width=%u>M",cellposition[0]-wptr->Contents.x);
			linefeed(h);
			}
		for (i=0; i < cellcount; i++ ) {
			fprintf(h,"<td width=%u>%u",cellwidth[i],i);
			linefeed(h);
			}
		}
	else	{
		fprintf(h,"<tr height=10>");
		linefeed(h);
		if ( cellposition[0] > wptr->Contents.x ) {
			fprintf(h,"<th width=%u>",cellposition[0]-wptr->Contents.x);
			linefeed(h);
			}
		for (i=0; i < cellcount; i++ ) {
			fprintf(h,"<th width=%u>",cellwidth[i]);
			linefeed(h);
			}
		}
	return(1);
}

private	int	generate_sort_items(FILE * h)
{
	int	pixels;
	int	colspan=1;
	int	rowspan=1;
	int	colindent=0;
	int	rowindent=0;
	int	colnumber=0;
	int	rownumber=0;
	int	i;
	int	x;
	int	items=0;
	struct sort_row  * rptr;
	struct sort_item * sptr;
	struct form_item * wptr;
	struct	sort_cell * cptr;
	struct window_control Window;

	/* Check Row and Column information is consistant */
	/* ---------------------------------------------- */
	for (	i=1; i	< rowcount; i++ ) {
		if (( rowposition[(i-1)] + rowheight[(i-1)] ) < rowposition[i] )
			rowheight[(i-1)] = (rowposition[i]-rowposition[(i-1)]);
		}

	if ( GenerateDebug ) {
		debug_sort_list( h );
		}

	if ( SortMan.window )
		items = generate_sort_window(h, SortMan.window );
	else	items = 0;

	if ( SortMan.window )
		rowindent = SortMan.window->Contents.x;
	else	rowindent = 0;

	rownumber = 0; rowspan=0;

	for ( i=0; i < cellcount; i++ ) { rowspanning[i] = 0; }

	for (	rptr = SortMan.firstrow;
		rptr != (struct sort_row *) 0;
		rptr = rptr->next ) {

		linefeed(h);
		fprintf(h,"<tr height=%u>",rowheight[rownumber]);

		colnumber = 0;

		for (	sptr = rptr->first;
			sptr != (struct sort_item *) 0;
			sptr = sptr->next ) {
			linefeed(h);

			if (!( wptr = sptr->widget))
				continue;

			html_widget_size(wptr,&Window,0);

			colspan = 0; 

			/* calculate the padding columns */
			/* ----------------------------- */
			while ( cellposition[colnumber] < Window.x ) {
				if ( colnumber < cellcount ) {
					colspan += 1;
					rowspanning[colnumber] = 1;
					colnumber++;
					}
				else	break;
				}

			if ( colspan ) {
				if ( colspan > 1 )			
					fprintf(h,"<td colspan=%u>",colspan);
				else	fprintf(h,"<td>");
				if ( GenerateDebug )
					fprintf(h,"%u",rownumber);
				}

			for (	colspan=0,pixels=0; 
				colnumber < cellcount; 
				colnumber++ ) {
				if ( cellposition[colnumber] == Window.x ) {
					do	{
						if ((colnumber+colspan) < cellcount) {
							pixels += cellwidth[colnumber+colspan];
							colspan++;
							}
						else	break;
						}
					while ( pixels < Window.w );
					break;
					}			
				}

			for (	rowspan=0,pixels=0; 
				rownumber < rowcount; 
				rownumber++ ) {
				if ( rowposition[rownumber] == Window.y ) {
					do	{
						if ((rownumber+rowspan) < rowcount) {
							pixels += rowheight[rownumber+rowspan];
							rowspan++;
							}
						else	break;
						}
					while ( pixels < Window.h );
					break;
					}			
				}

			if ( colspan > 1 )			
				fprintf(h,"<td colspan=%u",colspan);
			else	fprintf(h,"<td");

			
			if ( rowspan > 1 )
				fprintf(h," rowspan=%u>",rowspan);
			else	fprintf(h,">");

			generate_html(h,sptr->widget);

			for ( i=0; i < colspan; i++ ) {
				rowspanning[(colnumber+i)] = rowspan;
				}

			colnumber += colspan;
			items++;
			}
		colspan = 0;
		while ( (colnumber+colspan) < cellcount )
			colspan++;
		if ( colspan ) {
			if ( colspan > 1 )			
				fprintf(h,"<td colspan=%u>",colspan);
			else	fprintf(h,"<td>");
			}

		if ( GenerateDebug ) {
			printf("RowSpanInfo(%u) : ",rownumber);
			for (i=0; i < cellcount; i++ )
				printf(" %u",rowspanning[i]);
			printf("\r\n");
			}
		
		/* Adjust all rowspan values */
		/* ------------------------- */
		for ( i=0; i < cellcount; i++ ) 
			if ( rowspanning[i] )
				rowspanning[i]--;

		rownumber++;
		}


	while ( rownumber < rowcount ) {
		linefeed(h);
		fprintf(h,"<tr height=%u>",rowheight[rownumber]);
		fprintf(h,"<td colspan=%u>",cellcount);
		rownumber++;
		}

	return(items);
}		


#include "singwsi.c"
/*	----------------------------------------------------		*/
/*	h t m l _ f o r m _ p a g e ( handle, page, window )		*/
/*	----------------------------------------------------		*/
/*	This function is responsible for generation of tab		*/
/*	page forms models as html pages					*/
/*	----------------------------------------------------		*/

public	void	html_form_body( FILE * handle, int mode )
{
	int	isform=0;
	struct form_item * iptr;
	struct	sort_cell * cptr;

	stackitems = 0;

	/* ---------------------------------------------------------------- */
	/* Start Production of Html Document NOT Wasa Interface Description */
	/* ---------------------------------------------------------------- */
	if (!( start_html_document(
			handle, 
			(char *) 0,
			(char *) 0,	
			Context.Form->stylesheet,
			Context.Form->stylesheet,
			Context.Form
			 ) ))
		return;

	else if (!( open_server_description(Context.Form,1)))
		return;


	SortMan.formitems=1;

	isform = check_for_urlencoding(handle,Context.Form);

	/* ------------------------- */
	/* Generate Visible elements */
	/* ------------------------- */
	for (	iptr=Context.Form->first; 
		iptr != (struct form_item *) 0; 
		iptr = iptr->next )  {
		if ((!( iptr->Contents.w  ))
		||  (!( iptr->Contents.h  )))
			continue;
		else if (iptr->Contents.events->xo_show & _EVENT_IS_COND )
			continue;
		else if ((iptr->Contents.style & _FRAME_TYPE) == _LINE_FRAME)
			continue;
		else if ( is_file_Widget( iptr ) )
			continue;
		else 	generate_ahtml(handle,iptr);
		}
	/* ------------------------- */
	/* Close all open structures */
	/* ------------------------- */
	/* ------------------------ */
	/* Generate Hidden elements */
	/* ------------------------ */
	for (	iptr=Context.Form->first; 
		iptr != (struct form_item *) 0; 
		iptr = iptr->next )  {
		if ((!( iptr->Contents.w  ))
		||  (!( iptr->Contents.h  )))
			continue;
		else if (!(iptr->Contents.events->xo_show & _EVENT_IS_COND ))
			continue;
		else 	generate_hidden_html(handle,iptr);
		}

	while ( stackitems ) {
		switch (( istack[stackitems--] & _FRAME_TYPE )) {
			case	_INSET_FRAME :
			case	_OUTSET_FRAME :
			case	_GROOVE_FRAME :
			case	_RIDGE_FRAME :
			case	_TAB_FRAME :
				html_closure(handle,"table");
				break;
			case	_WINDOW_FRAME :
				html_closure(handle,"table");
				html_closure(handle,"table");
				html_closure(handle,"div");
				break;
			}
		}


	/* ----------------------------------------------------- */
	/* Terminate Forms, Wasa Description and Html Production */
	/* ----------------------------------------------------- */
	if ( isform ) { html_closure(handle,"form"); }
	(void) close_server_description();
	(void) close_html_document( handle, _DEFAULT_FOOTER );

	return;




}

/*	----------------------------------------------------		*/
/*	h t m l _ f o r m _ p a g e ( handle, page, window )		*/
/*	----------------------------------------------------		*/
/*	This function is responsible for generation of tab		*/
/*	page forms models as html pages					*/
/*	----------------------------------------------------		*/

public	void	html_form_page( FILE * handle, struct form_item * pptr, struct form_item * wptr )
{
	int	isform=0;
	struct form_item * iptr;
	struct	sort_cell * cptr;

	stackitems = 0;

	HtmlPageNumber  = pptr->Contents.page;

	/* ---------------------------------------------------------------- */
	/* Start Production of Html Document NOT Wasa Interface Description */
	/* ---------------------------------------------------------------- */
	if (!( start_html_document(
			handle, 
			(char *) 0,
			(char *) 0,	
			Context.Form->stylesheet,
			Context.Form->stylesheet,
			Context.Form
			 ) ))
		return;

	SortMan.formitems=1;

	isform = check_for_urlencoding(handle,Context.Form);

	/* ------------------------- */
	/* Generate Visible elements */
	/* ------------------------- */
	for (	iptr=Context.Form->first; 
		iptr != (struct form_item *) 0; 
		iptr = iptr->next )  {
		if ((!( iptr->Contents.w  ))
		||  (!( iptr->Contents.h  )))
			continue;
		else if (iptr->Contents.events->xo_show & _EVENT_IS_COND )
			continue;
		else if ((iptr->Contents.style & _FRAME_TYPE) == _LINE_FRAME)
			continue;
		else if ( is_file_Widget( iptr ) )
			continue;
		else if ((iptr->Contents.style & _FRAME_TYPE) == _TAB_FRAME)
			generate_ahtml(handle,iptr);
		else if (!( iptr->Contents.page ))
			generate_ahtml(handle,iptr);
		else if ( pptr->Contents.page !=  iptr->Contents.page )
			continue;
		else 	generate_ahtml(handle,iptr);
		}

	/* ------------------------- */
	/* Close all open structures */
	/* ------------------------- */
	while ( stackitems ) {
		switch (( istack[stackitems--] & _FRAME_TYPE )) {
			case	_INSET_FRAME :
			case	_OUTSET_FRAME :
			case	_GROOVE_FRAME :
			case	_RIDGE_FRAME :
			case	_TAB_FRAME :
				html_closure(handle,"table");
				break;
			case	_WINDOW_FRAME :
				html_closure(handle,"table");
				html_closure(handle,"table");
				html_closure(handle,"div");
				break;
			}
		}

	/* ------------------------ */
	/* Generate Hidden elements */
	/* ------------------------ */
	for (	iptr=Context.Form->first; 
		iptr != (struct form_item *) 0; 
		iptr = iptr->next )  {
		if ((!( iptr->Contents.w  ))
		||  (!( iptr->Contents.h  )))
			continue;
		else if (!(iptr->Contents.events->xo_show & _EVENT_IS_COND ))
			continue;
		else if (!( iptr->Contents.page ))
			generate_hidden_html(handle,iptr);
		else if ( pptr->Contents.page !=  iptr->Contents.page )
			continue;
		else 	generate_hidden_html(handle,iptr);
		}

	/* ----------------------------------------------------- */
	/* Terminate Forms, Wasa Description and Html Production */
	/* ----------------------------------------------------- */
	if ( isform ) { html_closure(handle,"form"); }
	(void) close_html_document( handle, _DEFAULT_FOOTER );

	return;




}


public	void	html_form_frame( FILE * handle, struct form_item * iptr,struct form_item * wptr)
{
	if (!( iptr ))
		return;

	html_form_page( handle, iptr, wptr );
	return;

}

public	void	html_form_tabset( FILE * handle, int mode )
{
	FILE *	wh=(FILE *) 0;
	struct	form_control * fptr;
	struct 	form_item * iptr=(struct form_item *)0;
	struct 	form_item * wptr=(struct form_item *)0;
	int	started=0;
	int	pagenumber;
	char *	natfic=(char *) 0;
	char *	nptr=(char *) 0;
	stackitems = 0;
	if (!( fptr = Context.Form))
		return;
	else if (!( fptr->identifier ))
		return;

	else if (!( open_server_description(Context.Form,1)))
		return;

	for (	iptr=Context.Form->first; 
		iptr != (struct form_item *) 0; 
		iptr = iptr->next )  {
		if ((!( iptr->Contents.w  ))
		||  (!( iptr->Contents.h  )))
			continue;
		else if ((iptr->Contents.style & _FRAME_TYPE) != _TAB_FRAME) 
			continue;
		else if (!( fptr->formflags &_MULTILINGUAL )) {
			sprintf(hbuffer,"page%u_%s",iptr->Contents.page,Context.Form->prodname);
			if (( wh = open_production_target(hbuffer,0)) != (FILE *) 0) {
				html_form_frame(wh,iptr,wptr);
				sprintf(hbuffer,"page%u_%s",iptr->Contents.page,Context.Form->prodname);
				close_production_target(wh,hbuffer);
				}
			}
		else	{
			switch ( fptr->natlang ) {
				case	0 : nptr = "en"; break;
				case	1 : nptr = "fr"; break;
				case	2 : nptr = "it"; break;
				case	3 : nptr = "es"; break;
				case	4 : nptr = "de"; break;
				case	5 : nptr = "nl"; break;
				case	6 : nptr = "pt"; break;
				default	  : nptr = "xx"; break;
				}

			mkdir(nptr,0664);

			if (( natfic = allocate( strlen( nptr ) + strlen( fptr->prodname ) + 32 ) ) != (char *) 0) {
				sprintf(natfic,"%s/page%u_%s",nptr,iptr->Contents.page,fptr->prodname);
				if (( wh = open_production_target(natfic,0)) != (FILE *) 0) {
					html_form_frame(wh,iptr,wptr);
					close_production_target(wh,natfic);
					}
				liberate( natfic );


				}


			}
		}

	close_server_description();

}

public	void	html_form_frameset( FILE * handle, int mode )
{
	FILE *	wh=(FILE *) 0;
	struct form_item * iptr=(struct form_item *)0;
	struct form_item * wptr=(struct form_item *)0;
	int	started=0;
	stackitems = 0;

	/* FRAMESET MASTER PAGE */
	/* -------------------- */

	if (!( start_html_frameset(
			handle, Context.Form->identifier, 
			1,"15%,85%",
			Context.Form->stylesheet,
			Context.Form->stylesheet
			 ) ))
		return;

	else if (!( open_server_description(Context.Form,1)))
		return;

	sprintf(hbuffer,"root_%s",Context.Form->prodname);
	html_frame( handle, hbuffer, "root",0,0,mode );
	sprintf(hbuffer,"page1_%s",Context.Form->prodname);
	html_frame( handle, hbuffer, "page",0,0,mode );

	(void) close_html_frameset( handle );

	/* FRAMESET ROOT FRAME PAGE */
	/* ------------------------ */

	sprintf(hbuffer,"root_%s",Context.Form->prodname);
	if (( wh = open_production_target(hbuffer,0)) != (FILE *) 0) {

		if (!( start_html_document(
				wh, 
				(char *) 0,
				(char *) 0,	
				Context.Form->stylesheet,
				Context.Form->stylesheet,
				Context.Form
				 ) )) {
			close_production_target(wh,hbuffer);
			return;
			}

		for (	iptr=Context.Form->first; 
			iptr != (struct form_item *) 0; 
			iptr = iptr->next )  {
			if ((!( iptr->Contents.w  ))
			||  (!( iptr->Contents.h  )))
				continue;
			else if ((iptr->Contents.style & _FRAME_TYPE) != _TAB_FRAME) {
				if ((iptr->Contents.style & _FRAME_TYPE) == _WINDOW_FRAME)
					wptr = iptr;
				continue;
				}
			if (!( started )) {
				if ( wptr ) {
					html_heading(wh,3,Context.Form->identifier);
					html_div(wh, wptr->Contents.align & 0x0007 );
					fprintf(wh,"<table class=tabhead width=%u>",wptr->Contents.w);
					fprintf(wh,"<tr>");
					linefeed(wh);
					}
				else	fprintf(wh,"<table class=tabhead><tr>");
				started++;				
				}			
			linefeed(wh);
			fprintf(wh,"<th class=tabview>");
			sprintf(hbuffer,"page%u_%s",iptr->Contents.page,Context.Form->prodname);
			if ( method_is_valid( abal_payload(iptr) ) )
				html_frame_target_anchor(wh,hbuffer,"page",abal_payload(iptr));
			}
		if ( started ) {
			if ( wptr )  {
				linefeed(wh);
				fprintf(wh,"</table>");
				fprintf(wh,"</div>");
				linefeed(wh);
				}
			else	{
				linefeed(wh);
				fprintf(wh,"</table>");
				}
			started=0;
			}
		(void) close_html_document( wh, _DEFAULT_FOOTER );
		sprintf(hbuffer,"root_%s",Context.Form->prodname);
		close_production_target(wh,hbuffer);
		}

	/* FRAMESET PAGE FRAMES */
	/* -------------------- */

	for (	iptr=Context.Form->first; 
		iptr != (struct form_item *) 0; 
		iptr = iptr->next )  {
		if ((!( iptr->Contents.w  ))
		||  (!( iptr->Contents.h  )))
			continue;
		else if ((iptr->Contents.style & _FRAME_TYPE) != _TAB_FRAME) 
			continue;
		else	{
			sprintf(hbuffer,"page%u_%s",iptr->Contents.page,Context.Form->prodname);
			if (( wh = open_production_target(hbuffer,0)) != (FILE *) 0) {
				html_form_frame(wh,iptr,wptr);
				sprintf(hbuffer,"page%u_%s",iptr->Contents.page,Context.Form->prodname);
				close_production_target(wh,hbuffer);
				}
			}
		}

	close_server_description();

	return;

}

#include "singagen.c"

private	int	html_national_form( FILE * handle, int mode, int automatic, int restrict, int parametric, int points )
{
	struct form_item * iptr;
	int	autotrad=1;
	int	holdmet=metricid;
	int	holdtext=TextPoints;

	set_parametrics( points, parametric );
	GenerateDebug = 0;
	if ( restrict & 1 )
		Restriction = 1;
	else	Restriction = 0;
	if ( restrict & 2 )
		ActiveAgentImages = 1;
	else	ActiveAgentImages = 0;
	stackitems = 0;
	HtmlPageNumber = 0;

	if ( Context.Form->pages != 0 ) 
		html_form_tabset(handle,mode);
	else	html_form_body  (handle,mode);

	if ( mode & 1 ) {
		generate_web_agent( Context.Form, automatic, GenerateDebug, 0 );
		if (!( automatic & _INHIBIT_PROPERTIES )) {
			autotrad = abal_production_parameters(Context.Form);
			}
		}
	TextPoints=holdtext;
	HtmlPageNumber = 0;
	GenerateDebug = 0;
	metricid=holdmet;
	return(autotrad);

}

public	int	export_html_form( FILE * handle, int mode, int automatic, int restrict, int parametric, int points, int hMethod )
{
	int	autotrad=1;
	FILE	*	h;
	struct	form_control *	fptr;
	int	holder;
	char *	natfic=(char *) 0;
	char	*	nptr;

	WSI.lock = 0;
	GenerateDebug = 0;
	if ( hMethod != 0 )
		set_agent_method(hMethod,"POST");
	else	set_agent_method(hMethod,"GET");
	if ( restrict & 1 )
		Restriction = 1;
	else	Restriction = 0;
	if ( restrict & 2 )
		ActiveAgentImages = 1;
	else	ActiveAgentImages = 0;

	if (!( fptr = Context.Form ))
		return(0);

	/* Simple Single Language Form */
	/* --------------------------- */
	else if (!( fptr->formflags &_MULTILINGUAL )) {
		return( html_national_form( handle, mode, automatic, GenerateDebug, parametric, points ) );
		}
	else	{
		/* ---------------------------------------------------------------- */
		/* Start Production of Html Document NOT Wasa Interface Description */
		/* ---------------------------------------------------------------- */
		if ( mode & 1 ) {
			generate_web_agent( Context.Form, automatic, GenerateDebug, 0 );
			if (!( automatic & _INHIBIT_PROPERTIES )) {
				autotrad = abal_production_parameters(Context.Form);
				}
			}

		if (!( start_html_document(
				handle, 
				(char *) 0,
				(char *) 0,	
				Context.Form->stylesheet,
				Context.Form->stylesheet,
				(struct form_control *) 0
			 ) ))
			return;
		else if (!( open_server_description(Context.Form,1)))
			return;

		/* -------------------------------- */
		/* Generate multiple national pages */
		/* -------------------------------- */
		WSI.lock = 1;
		holder = fptr->natlang;
		fprintf(handle,"<div align=center><table><tr>");
		linefeed(handle);
		mode &= ~1;

		for (fptr->natlang=0; fptr->natlang < 8; fptr->natlang++ ) {

			fprintf(handle,"<th><a href=");
			switch ( fptr->natlang ) {
				case	0 : nptr = "en"; break;
				case	1 : nptr = "fr"; break;
				case	2 : nptr = "it"; break;
				case	3 : nptr = "es"; break;
				case	4 : nptr = "de"; break;
				case	5 : nptr = "nl"; break;
				case	6 : nptr = "pt"; break;
				default	  : nptr = "xx"; break;
				}

			mkdir(nptr,0664);

			if (!( natfic = allocate( strlen( nptr ) + strlen( fptr->prodname ) + 16 ) ))
				break;
			else	sprintf(natfic,"%s/%s",nptr,fptr->prodname);

			fprintf(handle,"%c%s%c>",__QUOTE,natfic,__QUOTE);

			html_open_tag(handle,"img");
			switch ( fptr->natlang ) {
				case	0 : nptr = "/home/abal3/images/en.gif"; break;
				case	1 : nptr = "/home/abal3/images/fr.gif"; break;
				case	2 : nptr = "/home/abal3/images/it.gif"; break;
				case	3 : nptr = "/home/abal3/images/es.gif"; break;
				case	4 : nptr = "/home/abal3/images/de.gif"; break;
				case	5 : nptr = "/home/abal3/images/nl.gif"; break;
				case	6 : nptr = "/home/abal3/images/pt.gif"; break;
				default	  : nptr = "/home/abal3/images/xx.gif"; break;
				}
			html_field(handle,"src",nptr);
			html_field(handle,"alt",nptr);
			html_close_tag(handle,"img");
			html_closure(handle,"a");
			linefeed(handle);

			if (!( h = open_production_target(natfic,0))) 
				break;

			(void) html_national_form( h, mode , automatic, GenerateDebug, parametric, points );
			close_production_target(h,natfic);
			liberate( natfic );
			}

		html_closure(handle,"table");
		html_closure(handle,"div");
		linefeed(handle);

		/* Terminate Document */
		/* ------------------ */
		fptr->natlang = holder;
		WSI.lock = 0;

		(void) close_server_description();
		(void) close_html_document( handle, _DEFAULT_FOOTER );

		return(autotrad);
		}
}

public	void	use_navigator( char * filename, int namelength )
{
	int	i;
	char *	nptr;
	if (!( nptr = allocate( namelength + 1 ) ))
		return;
	else	{
		memcpy(nptr,filename,namelength);
		for (i=0; i < namelength; i++ ) {
			if ( *(nptr+i) == ' ' )
				break;
			else if (!( *(nptr+i)))
				break;
			}
		*(nptr+i) = 0;		
		if (!(visual_help( nptr )))
			draw_console();
		liberate( nptr );
		return;
		}
}

public	int	use_html_navigator(char * aptr, int automatic)
{
	char	*	sptr;
	char	*	command;
	int		alen=0;
	char		xbuffer[64];

	if (!( fn_parser( aptr, xbuffer, 0x0010 ) ))
		return(0);
	if ((!( upper_compare( xbuffer, ".HTM"  ) ))
	&&  (!( upper_compare( xbuffer, ".HTML" ) )))
		return(0);
	else	{
		use_navigator( aptr, strlen( aptr ) );
		return(1);
		}

}

#endif	/* _singhtml_c */
	/* ----------- */


